This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
apiHelpers.js
client/assessmentApi.js
client/auditApi.js
client/clientApi.js
client/clientUserApi.js
client/incidentApi.js
client/initialAssessmentApi.js
client/reportGenerationApi.js
client/reportingApi.js
client/riskAssessmentApi.js
client/securityAssessmentsApi.js
client/securityInitiativesApi.js
client/securityObjectivesApi.js
grc_application/grcUserApi.js
grc_application/settingsApi.js
index.js
mocks/artifactsMockData.js
mocks/assessmentMockData.js
mocks/atoTrackerMockData.js
mocks/authorizationMockData.js
mocks/data/assessment/advanced_questions.json
mocks/data/assessment/assessments.json
mocks/data/assessment/authorization.json
mocks/data/assessment/basic_questions.json
mocks/data/assessment/controls.json
mocks/data/assessment/documents.json
mocks/data/assessment/plans.json
mocks/data/assessment/scan_results.json
mocks/data/auth/roles.json
mocks/data/auth/users.json
mocks/data/client_data/client_users.json
mocks/data/client_data/clients.json
mocks/data/client_data/departments.json
mocks/data/client_data/documents.json
mocks/data/client_data/key_personnel.json
mocks/data/client_data/reference_data.json
mocks/data/incidents/enums.json
mocks/data/incidents/incidents.json
mocks/data/system_data/packages.json
mocks/data/system_data/risks.json
mocks/data/system_data/systems.json
mocks/db.json
mocks/generateDb.js
mocks/incidentMockData.js
mocks/middleware.js
mocks/riskMockData.js
mocks/routes.json
mocks/securityAssessmentsMockData.js
mocks/securityControlsMockData.js
mocks/securityInitiativesMockData.js
mocks/securityObjectivesMockData.js
mocks/systemComponentsMockData.js
mocks/systemMockData.js
mocks/userMockData.js
system/artifactsApi.js
system/atoTrackerApi.js
system/authorizationApi.js
system/systemApi.js
system/systemCategorizationApi.js
system/systemComponentsApi.js
system/systemControlsApi.js

================================================================
Files
================================================================

================
File: apiHelpers.js
================
// Helper to simulate API delay
export const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Helper to generate ISO date string without time
export const getCurrentDate = () => new Date().toISOString().split('T')[0];

// Helper to handle API errors
export class ApiError extends Error {
  constructor(message, status = 500) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
  }
}

// Helper to validate required fields
export const validateRequired = (data, fields) => {
  const missing = fields.filter(field => !data[field]);
  if (missing.length > 0) {
    throw new ApiError(`Missing required fields: ${missing.join(', ')}`, 400);
  }
};

// Helper to validate email format
export const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw new ApiError('Invalid email format', 400);
  }
};

// Helper to check if record exists
export const checkExists = (item, itemType) => {
  if (!item) {
    throw new ApiError(`${itemType} not found`, 404);
  }
};

// Base API URL
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '';

// Default headers
const defaultHeaders = {
  'Content-Type': 'application/json',
};

// Helper to handle API responses
export const handleApiResponse = async (response) => {
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new ApiError(error.message || 'API request failed', response.status);
  }
  return response.json();
};

// Helper to handle API errors
export const handleApiError = (error) => {
  if (error instanceof ApiError) {
    throw error;
  }
  throw new ApiError(error.message || 'An unexpected error occurred');
};

// HTTP method helpers
export const fetchWithAuth = async (url, options = {}) => {
  const token = localStorage.getItem('token');
  const headers = {
    ...defaultHeaders,
    ...(token ? { Authorization: `Bearer ${token}` } : {}),
    ...options.headers,
  };

  const response = await fetch(`${API_BASE_URL}${url}`, {
    ...options,
    headers,
  });

  return handleApiResponse(response);
};

export const get = async (url, params = {}) => {
  const queryString = new URLSearchParams(params).toString();
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  
  return fetchWithAuth(fullUrl, {
    method: 'GET',
  });
};

export const post = async (url, data) => {
  return fetchWithAuth(url, {
    method: 'POST',
    body: JSON.stringify(data),
  });
};

export const put = async (url, data) => {
  return fetchWithAuth(url, {
    method: 'PUT',
    body: JSON.stringify(data),
  });
};

export const del = async (url) => {
  return fetchWithAuth(url, {
    method: 'DELETE',
  });
};

================
File: client/assessmentApi.js
================
const API_URL = 'http://localhost:3001';

const handleError = (error) => {
  console.error('API Error:', error);
  throw error;
};

const assessmentApi = {
  // Assessment Plan APIs
  getAssessmentPlan: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentPlans?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch assessment plan');
      const plans = await response.json();
      return plans[0]; // Return the first matching plan
    } catch (error) {
      return handleError(error);
    }
  },

  updateAssessmentPlan: async (clientId, systemId, planData) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentPlans/${planData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...planData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update assessment plan');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Security Testing APIs
  getScanResults: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/scanResults?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch scan results');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  uploadScanResults: async (clientId, systemId, formData) => {
    try {
      const newScan = {
        id: `scan-${Date.now()}`,
        type: formData.get('type') || 'STIG Scan',
        date: new Date().toISOString(),
        findings: {
          high: parseInt(formData.get('highFindings') || '0'),
          medium: parseInt(formData.get('mediumFindings') || '0'),
          low: parseInt(formData.get('lowFindings') || '0')
        },
        status: 'Completed',
        downloadUrl: '#',
        detailsUrl: '#',
        clientId,
        systemId,
        assessmentPlanId: formData.get('assessmentPlanId'),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      const response = await fetch(
        `${API_URL}/scanResults`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(newScan)
        }
      );
      if (!response.ok) throw new Error('Failed to upload scan results');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  deleteScanResult: async (clientId, systemId, scanId) => {
    try {
      const response = await fetch(
        `${API_URL}/scanResults/${scanId}`,
        {
          method: 'DELETE'
        }
      );
      if (!response.ok) throw new Error('Failed to delete scan result');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Control Assessment APIs
  getControlAssessments: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/controls?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch control assessments');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  updateControlAssessment: async (clientId, systemId, controlData) => {
    try {
      const response = await fetch(
        `${API_URL}/controls/${controlData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...controlData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update control assessment');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Documentation Review APIs
  getDocumentationReview: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch documentation review');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  updateDocumentReview: async (clientId, systemId, documentData) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments/${documentData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...documentData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update document review');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  getDocumentDownloadUrl: async (clientId, systemId, documentId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments/${documentId}`
      );
      if (!response.ok) throw new Error('Failed to get document download URL');
      const doc = await response.json();
      return doc.downloadUrl || '#';
    } catch (error) {
      return handleError(error);
    }
  },
};

export default assessmentApi;

================
File: client/auditApi.js
================
import { validateRequired } from '../apiHelpers';
import riskAssessmentApi from './riskAssessmentApi';

const API_URL = 'http://localhost:3001';

// Source types that map to different APIs
const SOURCE_TYPES = {
  SECURITY_ASSESSMENT: 'security_assessment',
  VULNERABILITY_SCAN: 'vulnerability_scan',
  COMPLIANCE_REVIEW: 'compliance_review',
  EXTERNAL_AUDIT: 'external_audit',
  INTERNAL_AUDIT: 'internal_audit',
  INCIDENT_REVIEW: 'incident_review'
};

const SEVERITY_LEVELS = ['critical', 'high', 'medium', 'low', 'informational'];
const FINDING_STATUSES = ['open', 'in_progress', 'closed', 'reopened', 'duplicate', 'deferred'];
const COMMON_TAGS = [
  'access-control',
  'authentication',
  'authorization',
  'configuration',
  'encryption',
  'network-security',
  'patch-management',
  'policy-violation',
  'security-controls',
  'third-party',
  'vulnerability'
];

export const auditApi = {
  // Get all findings by aggregating from different sources
  getFindings: async (clientId, filters = {}) => {
    validateRequired({ clientId }, ['clientId']);
    const numericClientId = Number(clientId);

    try {
      // Get all assessments for the client
      const response = await fetch(`${API_URL}/assessmentHistory?clientId=${numericClientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch assessments');
      }
      const assessments = await response.json();
      
      // Extract findings from all assessments
      let allFindings = assessments.flatMap(assessment => 
        (assessment.generatedFindings || []).map(finding => ({
          ...finding,
          sourceType: SOURCE_TYPES.SECURITY_ASSESSMENT,
          sourceDetails: `Security Assessment: ${assessment.name}`,
          createdDate: assessment.date,
          assessmentId: assessment.id
        }))
      );

      // Apply filters
      if (filters.sourceType) {
        allFindings = allFindings.filter(f => f.sourceType === filters.sourceType);
      }
      if (filters.severity) {
        allFindings = allFindings.filter(f => f.severity === filters.severity);
      }
      if (filters.status) {
        allFindings = allFindings.filter(f => f.status === filters.status);
      }
      if (filters.tags && filters.tags.length > 0) {
        allFindings = allFindings.filter(f => 
          filters.tags.some(tag => f.tags?.includes(tag))
        );
      }

      return allFindings;
    } catch (error) {
      throw new Error(`Failed to fetch findings: ${error.message}`);
    }
  },

  // Get finding metrics
  getFindingMetrics: async (clientId) => {
    try {
      const findings = await auditApi.getFindings(Number(clientId));

      return {
        total: findings.length,
        bySeverity: {
          critical: findings.filter(f => f.severity === 'critical').length,
          high: findings.filter(f => f.severity === 'high').length,
          medium: findings.filter(f => f.severity === 'medium').length,
          low: findings.filter(f => f.severity === 'low').length,
          informational: findings.filter(f => f.severity === 'informational').length
        },
        byStatus: {
          open: findings.filter(f => f.status === 'open').length,
          in_progress: findings.filter(f => f.status === 'in_progress').length,
          closed: findings.filter(f => f.status === 'closed').length,
          reopened: findings.filter(f => f.status === 'reopened').length,
          duplicate: findings.filter(f => f.status === 'duplicate').length,
          deferred: findings.filter(f => f.status === 'deferred').length
        },
        bySource: {
          security_assessment: findings.filter(f => f.sourceType === SOURCE_TYPES.SECURITY_ASSESSMENT).length,
          vulnerability_scan: findings.filter(f => f.sourceType === SOURCE_TYPES.VULNERABILITY_SCAN).length,
          compliance_review: findings.filter(f => f.sourceType === SOURCE_TYPES.COMPLIANCE_REVIEW).length,
          external_audit: findings.filter(f => f.sourceType === SOURCE_TYPES.EXTERNAL_AUDIT).length,
          internal_audit: findings.filter(f => f.sourceType === SOURCE_TYPES.INTERNAL_AUDIT).length,
          incident_review: findings.filter(f => f.sourceType === SOURCE_TYPES.INCIDENT_REVIEW).length
        },
        promotedToRisk: findings.filter(f => f.promotedToRisk).length
      };
    } catch (error) {
      throw new Error(`Failed to fetch finding metrics: ${error.message}`);
    }
  },

  // Get source types
  getSourceTypes: async () => {
    return Object.values(SOURCE_TYPES);
  },

  // Get severity levels
  getSeverityLevels: async () => {
    return [...SEVERITY_LEVELS];
  },

  // Get finding statuses
  getFindingStatuses: async () => {
    return [...FINDING_STATUSES];
  },

  // Get common tags
  getCommonTags: async () => {
    return [...COMMON_TAGS];
  },

  // Promote finding to risk
  promoteToRisk: async (findingId, riskData) => {
    validateRequired({ findingId, ...riskData }, ['findingId', 'name', 'description', 'impact', 'likelihood', 'category']);
    
    try {
      // Create a new risk assessment
      const risk = await riskAssessmentApi.createRisk(riskData.clientId, {
        name: riskData.name,
        description: riskData.description,
        impact: riskData.impact,
        likelihood: riskData.likelihood,
        category: riskData.category,
        source: `Finding: ${findingId}`,
        status: 'open'
      });

      // Update the original finding to mark it as promoted
      const sourceType = findingId.split('-')[0];
      if (sourceType === 'sa') {
        const assessmentId = findingId.substring(3);
        const response = await fetch(`${API_URL}/assessmentHistory/${assessmentId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            generatedFindings: {
              [findingId]: {
                status: 'promoted_to_risk',
                riskId: risk.id,
                promotedToRisk: true
              }
            }
          })
        });

        if (!response.ok) {
          throw new Error('Failed to update finding promotion status');
        }
      }

      return { success: true, riskId: risk.id };
    } catch (error) {
      throw new Error(`Failed to promote finding to risk: ${error.message}`);
    }
  }
};

export default auditApi;

================
File: client/clientApi.js
================
import { 
  validateRequired, 
  validateEmail, 
  getCurrentDate, 
  ApiError,
  get,
  post,
  put,
  del
} from '../apiHelpers';

const API_URL = 'http://localhost:3001';

const clientApi = {
  // Get all clients
  getClients: async () => {
    return get(`${API_URL}/clients`);
  },

  // Get available industries
  getIndustries: async () => {
    return get(`${API_URL}/industries`);
  },

  // Get available client sizes
  getClientSizes: async () => {
    return get(`${API_URL}/clientSizes`);
  },

  // Get available client statuses
  getClientStatuses: async () => {
    return get(`${API_URL}/clientStatuses`);
  },

  // Get client by ID
  getClient: async (id) => {
    const numericId = Number(id);
    return get(`${API_URL}/clients/${numericId}`);
  },

  // Create new client
  createClient: async (clientData) => {
    validateRequired(clientData, ['name', 'industry', 'email', 'phone', 'primaryContact']);
    validateEmail(clientData.email);

    const newClient = {
      ...clientData,
      createdAt: getCurrentDate(),
      lastActivity: getCurrentDate(),
      complianceScore: 0,
      status: 'active',
      address: clientData.address || {
        street: '',
        city: '',
        state: '',
        zip: '',
        country: ''
      },
      size: clientData.size || '',
      employeeCount: clientData.employeeCount || 0,
      website: clientData.website || ''
    };

    return post(`${API_URL}/clients`, newClient);
  },

  // Update client
  updateClient: async (id, updates) => {
    const numericId = Number(id);
    
    if (updates.email) {
      validateEmail(updates.email);
    }

    // Get current client data
    const currentClient = await get(`${API_URL}/clients/${numericId}`);

    const updatedClient = {
      ...currentClient,
      ...updates,
      lastActivity: getCurrentDate()
    };

    return put(`${API_URL}/clients/${numericId}`, updatedClient);
  },

  // Delete client
  deleteClient: async (id) => {
    const numericId = Number(id);
    return del(`${API_URL}/clients/${numericId}`);
  },

  // Get client compliance overview
  getClientCompliance: async (id) => {
    const numericId = Number(id);
    const client = await get(`${API_URL}/clients/${numericId}`);
    
    return {
      clientId: numericId,
      overallScore: client.complianceScore,
      lastUpdated: client.lastActivity,
      frameworks: {
        nist: 85,
        hipaa: 90,
        pci: 88
      }
    };
  },

  // Department Management
  getDepartments: async (clientId) => {
    const numericClientId = Number(clientId);
    return get(`${API_URL}/departments`, { clientId: numericClientId });
  },

  createDepartment: async (clientId, departmentData) => {
    validateRequired(departmentData, ['name', 'head', 'headTitle']);

    const newDepartment = {
      clientId: Number(clientId),
      ...departmentData,
      employeeCount: departmentData.employeeCount || 0,
      positions: departmentData.positions || [],
      lastUpdated: getCurrentDate()
    };

    // Ensure positions have proper structure
    if (newDepartment.positions.length > 0) {
      newDepartment.positions = newDepartment.positions.map((position, index) => ({
        id: position.id || index + 1,
        name: position.name
      }));
    }

    return post(`${API_URL}/departments`, newDepartment);
  },

  updateDepartment: async (clientId, departmentId, updates) => {
    const numericClientId = Number(clientId);
    const numericDepartmentId = Number(departmentId);

    // Get current department data
    const currentDepartment = await get(`${API_URL}/departments/${numericDepartmentId}`);

    // Verify department belongs to client
    if (currentDepartment.clientId !== numericClientId) {
      throw new ApiError('Department not found', 404);
    }

    // Handle positions update
    let positions = currentDepartment.positions;
    if (updates.positions) {
      positions = updates.positions.map((position, index) => ({
        id: position.id || index + 1,
        name: position.name
      }));
    }

    const updatedDepartment = {
      ...currentDepartment,
      ...updates,
      positions,
      clientId: numericClientId,
      lastUpdated: getCurrentDate()
    };

    return put(`${API_URL}/departments/${numericDepartmentId}`, updatedDepartment);
  },

  deleteDepartment: async (clientId, departmentId) => {
    const numericClientId = Number(clientId);
    const numericDepartmentId = Number(departmentId);

    // Verify department belongs to client before deletion
    const department = await get(`${API_URL}/departments/${numericDepartmentId}`);
    if (department.clientId !== numericClientId) {
      throw new ApiError('Department not found', 404);
    }

    return del(`${API_URL}/departments/${numericDepartmentId}`);
  },

  // Document Management
  getDocumentCategories: async () => {
    return get(`${API_URL}/documentCategories`);
  },

  getDocumentTypes: async () => {
    return get(`${API_URL}/documentTypes`);
  },

  getCompanyDocuments: async (clientId) => {
    const numericClientId = Number(clientId);
    return get(`${API_URL}/documents`, { clientId: numericClientId });
  },

  uploadDocument: async (clientId, formData) => {
    const file = formData.get('file');
    if (!file) {
      throw new ApiError('No file provided', 400);
    }

    const fileType = file.name.split('.').pop().toUpperCase();
    const documentTypes = await get(`${API_URL}/documentTypes`);
    const validTypes = documentTypes.map(type => type.name);
    
    if (!validTypes.includes(fileType)) {
      throw new ApiError('Unsupported file type', 400);
    }

    const newDocument = {
      clientId: Number(clientId),
      name: file.name,
      type: fileType,
      lastUpdated: getCurrentDate(),
      category: formData.get('category') || 'General',
      size: file.size,
      uploadedBy: 'Current User' // This should be replaced with actual user info from auth context
    };

    return post(`${API_URL}/documents`, newDocument);
  },

  downloadDocument: async (clientId, documentId) => {
    const numericClientId = Number(clientId);
    const numericDocumentId = Number(documentId);

    // Verify document exists and belongs to client
    const document = await get(`${API_URL}/documents/${numericDocumentId}`);
    if (document.clientId !== numericClientId) {
      throw new ApiError('Document not found', 404);
    }

    // In a real implementation, this would handle file download
    return { success: true, message: 'Document download initiated' };
  },

  deleteDocument: async (clientId, documentId) => {
    const numericClientId = Number(clientId);
    const numericDocumentId = Number(documentId);

    // Verify document belongs to client before deletion
    const document = await get(`${API_URL}/documents/${numericDocumentId}`);
    if (document.clientId !== numericClientId) {
      throw new ApiError('Document not found', 404);
    }

    return del(`${API_URL}/documents/${numericDocumentId}`);
  }
};

export default clientApi;

================
File: client/clientUserApi.js
================
import { validateRequired, validateEmail, ApiError } from '../apiHelpers';

const API_BASE_URL = 'http://localhost:3001';

// Helper function for API calls
const fetchApi = async (endpoint, options = {}) => {
  const response = await fetch(`${API_BASE_URL}/${endpoint}`, {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    },
    ...options
  });

  if (!response.ok) {
    throw new ApiError(`API Error: ${response.statusText}`, response.status);
  }

  return response.json();
};

// Login user
export const login = async ({ email, password }) => {
  validateRequired({ email, password }, ['email', 'password']);
  validateEmail(email);

  const users = await fetchApi(`users?email=${encodeURIComponent(email)}`);
  const user = users[0];

  if (!user || password !== 'admin123') { // Mock password check
    throw new ApiError('Invalid email or password', 401);
  }

  const token = `mock-token-${Date.now()}`;

  return {
    user: {
      id: user.id,
      email: user.email,
      username: user.username,
      role: user.role,
      permissions: user.permissions,
      clientId: Number(user.clientId)
    },
    token
  };
};

// Get all users
export const getUsers = async (clientId = null) => {
  const endpoint = clientId !== null 
    ? `users?clientId=${encodeURIComponent(clientId)}`
    : 'users';
  const users = await fetchApi(endpoint);
  return users.map(user => ({
    ...user,
    clientId: user.clientId !== null ? Number(user.clientId) : null
  }));
};

// Get available roles
export const getRoles = async () => {
  const roles = await fetchApi('roles');
  return roles.map(role => role.name);
};

// Get available permissions
export const getPermissions = async () => {
  const permissions = await fetchApi('permissions');
  return permissions.map(permission => permission.name);
};

// Get available departments
export const getDepartments = async () => {
  const departments = await fetchApi('departments');
  return departments.map(dept => dept.name);
};

// Get available titles
export const getTitles = async () => {
  const titles = await fetchApi('titles');
  return titles.map(title => title.name);
};

// Get user statuses
export const getUserStatuses = async () => {
  const statuses = await fetchApi('userStatus');
  return statuses.map(status => status.name);
};

// Get user by ID
export const getUser = async (id) => {
  const user = await fetchApi(`users/${id}`);
  return {
    ...user,
    clientId: user.clientId !== null ? Number(user.clientId) : null
  };
};

// Create new user
export const createUser = async (userData) => {
  validateRequired(userData, ['username', 'email', 'role', 'clientId']);
  validateEmail(userData.email);

  // Validate role exists
  const roles = await getRoles();
  if (!roles.includes(userData.role)) {
    throw new ApiError('Invalid role specified', 400);
  }

  // Check for existing email
  const existingUsers = await fetchApi(`users?email=${encodeURIComponent(userData.email)}`);
  if (existingUsers.length > 0) {
    throw new ApiError('Email already exists', 400);
  }

  // Get role permissions
  const rolePermissions = await fetchApi(`rolePermissions?id=${encodeURIComponent(userData.role)}`);
  const permissions = rolePermissions[0]?.permissions || ['view'];

  const newUser = {
    ...userData,
    clientId: userData.clientId !== null ? Number(userData.clientId) : null,
    isActive: true,
    lastActive: new Date().toISOString(),
    permissions
  };

  return fetchApi('users', {
    method: 'POST',
    body: JSON.stringify(newUser)
  });
};

// Update user
export const updateUser = async (id, updates) => {
  if (updates.email) {
    validateEmail(updates.email);
    // Check if email is taken by another user
    const existingUsers = await fetchApi(`users?email=${encodeURIComponent(updates.email)}`);
    if (existingUsers.some(u => u.id !== id)) {
      throw new ApiError('Email already exists', 400);
    }
  }

  // Update permissions if role is changed
  if (updates.role) {
    const roles = await getRoles();
    if (!roles.includes(updates.role)) {
      throw new ApiError('Invalid role specified', 400);
    }
    const rolePermissions = await fetchApi(`rolePermissions?id=${encodeURIComponent(updates.role)}`);
    updates.permissions = rolePermissions[0]?.permissions || ['view'];
  }

  // Convert clientId to number if it's being updated
  if (updates.clientId !== undefined) {
    updates.clientId = updates.clientId !== null ? Number(updates.clientId) : null;
  }

  const updatedUser = {
    ...updates,
    lastActive: new Date().toISOString()
  };

  return fetchApi(`users/${id}`, {
    method: 'PATCH',
    body: JSON.stringify(updatedUser)
  });
};

// Delete user
export const deleteUser = async (id) => {
  await fetchApi(`users/${id}`, { method: 'DELETE' });
  return { success: true, message: 'User deleted successfully' };
};

// Get user permissions
export const getUserPermissions = async (id) => {
  const user = await getUser(id);
  return {
    userId: id,
    role: user.role,
    permissions: user.permissions,
    clientId: user.clientId !== null ? Number(user.clientId) : null,
    lastUpdated: user.lastActive
  };
};

// Check if user has specific permission
export const hasPermission = async (userId, permission, clientId = null) => {
  try {
    const user = await getUser(userId);
    if (!user) return false;

    // System admins have all permissions
    if (user.role === 'SYSTEM_ADMIN') return true;

    // For client users, check if they're accessing their own client
    if (clientId !== null) {
      const numericClientId = Number(clientId);
      if (user.clientId !== numericClientId) return false;
    }

    return user.permissions.includes(permission) || user.permissions.includes('all');
  } catch {
    console.error(`Failed to check permissions for user ${userId}`);
    return false;
  }
};

// Export all functions as a default object
const clientUserApi = {
  login,
  getUsers,
  getRoles,
  getPermissions,
  getDepartments,
  getTitles,
  getUserStatuses,
  getUser,
  createUser,
  updateUser,
  deleteUser,
  getUserPermissions,
  hasPermission
};

export default clientUserApi;

================
File: client/incidentApi.js
================
import { validateRequired } from '../apiHelpers';

const BASE_URL = '/api';

const DEFAULT_STATS = {
  total: 0,
  active: 0,
  resolved: 0,
  avgResolutionTime: 0,
  bySeverity: {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0
  },
  byType: {}
};

const incidentApi = {
  // Get all incidents
  getIncidents: async (clientId) => {
    const response = await fetch(`${BASE_URL}/incidents?clientId=${clientId}`);
    if (!response.ok) throw new Error('Failed to fetch incidents');
    return response.json();
  },

  // Get single incident
  getIncident: async (clientId, incidentId) => {
    const response = await fetch(`${BASE_URL}/incidents/${incidentId}?clientId=${clientId}`);
    if (!response.ok) {
      if (response.status === 404) throw new Error('Incident not found');
      throw new Error('Failed to fetch incident');
    }
    return response.json();
  },

  // Create new incident
  createIncident: async (clientId, incidentData) => {
    validateRequired(incidentData, ['title', 'type', 'severity', 'priority', 'description']);

    const response = await fetch(`${BASE_URL}/incidents`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        ...incidentData,
        clientId: Number(clientId),
        status: 'active',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        resolvedAt: null,
        actions: []
      })
    });

    if (!response.ok) throw new Error('Failed to create incident');
    return response.json();
  },

  // Update incident
  updateIncident: async (clientId, incidentId, updates) => {
    const response = await fetch(`${BASE_URL}/incidents/${incidentId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        ...updates,
        clientId: Number(clientId),
        updatedAt: new Date().toISOString(),
        // If status is being updated to 'resolved', set resolvedAt
        ...(updates.status === 'resolved' ? { resolvedAt: new Date().toISOString() } : {})
      })
    });

    if (!response.ok) {
      if (response.status === 404) throw new Error('Incident not found');
      throw new Error('Failed to update incident');
    }
    return response.json();
  },

  // Add action to incident
  addAction: async (clientId, incidentId, actionData) => {
    validateRequired(actionData, ['type', 'description', 'performedBy']);

    const incident = await incidentApi.getIncident(clientId, incidentId);
    const newAction = {
      id: Math.max(0, ...incident.actions.map(a => a.id)) + 1,
      timestamp: new Date().toISOString(),
      ...actionData
    };

    const response = await fetch(`${BASE_URL}/incidents/${incidentId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        actions: [...incident.actions, newAction],
        updatedAt: new Date().toISOString()
      })
    });

    if (!response.ok) throw new Error('Failed to add action');
    return newAction;
  },

  // Get incident types
  getIncidentTypes: async () => {
    const response = await fetch(`${BASE_URL}/incidentTypes`);
    if (!response.ok) throw new Error('Failed to fetch incident types');
    return response.json();
  },

  // Get incident severities
  getIncidentSeverities: async () => {
    const response = await fetch(`${BASE_URL}/incidentSeverities`);
    if (!response.ok) throw new Error('Failed to fetch incident severities');
    return response.json();
  },

  // Get incident statuses
  getIncidentStatuses: async () => {
    const response = await fetch(`${BASE_URL}/incidentStatuses`);
    if (!response.ok) throw new Error('Failed to fetch incident statuses');
    return response.json();
  },

  // Get incident priorities
  getIncidentPriorities: async () => {
    const response = await fetch(`${BASE_URL}/incidentPriorities`);
    if (!response.ok) throw new Error('Failed to fetch incident priorities');
    return response.json();
  },

  // Get action types
  getActionTypes: async () => {
    const response = await fetch(`${BASE_URL}/actionTypes`);
    if (!response.ok) throw new Error('Failed to fetch action types');
    return response.json();
  },

  // Get teams
  getTeams: async () => {
    const response = await fetch(`${BASE_URL}/teams`);
    if (!response.ok) throw new Error('Failed to fetch teams');
    return response.json();
  },

  // Get system types
  getSystemTypes: async () => {
    const response = await fetch(`${BASE_URL}/systemTypes`);
    if (!response.ok) throw new Error('Failed to fetch system types');
    return response.json();
  },

  // Get incident statistics
  getIncidentStats: async (clientId) => {
    try {
      const [incidents, incidentTypes] = await Promise.all([
        incidentApi.getIncidents(clientId),
        incidentApi.getIncidentTypes()
      ]);
      
      if (!Array.isArray(incidents) || incidents.length === 0) {
        return {
          ...DEFAULT_STATS,
          byType: incidentTypes.reduce((acc, type) => ({ ...acc, [type]: 0 }), {})
        };
      }

      const activeIncidents = incidents.filter(inc => inc.status === 'active');
      const resolvedIncidents = incidents.filter(inc => inc.status === 'resolved');

      // Calculate average resolution time for resolved incidents
      const avgResolutionTime = resolvedIncidents.length ? 
        resolvedIncidents.reduce((acc, inc) => {
          const resolutionTime = new Date(inc.resolvedAt) - new Date(inc.createdAt);
          return acc + resolutionTime;
        }, 0) / resolvedIncidents.length : 0;

      return {
        total: incidents.length,
        active: activeIncidents.length,
        resolved: resolvedIncidents.length,
        avgResolutionTime: Math.round(avgResolutionTime / (1000 * 60 * 60)), // Convert to hours
        bySeverity: {
          critical: incidents.filter(inc => inc.severity === 'critical').length,
          high: incidents.filter(inc => inc.severity === 'high').length,
          medium: incidents.filter(inc => inc.severity === 'medium').length,
          low: incidents.filter(inc => inc.severity === 'low').length
        },
        byType: incidentTypes.reduce((acc, type) => ({
          ...acc,
          [type]: incidents.filter(inc => inc.type === type).length
        }), {})
      };
    } catch (error) {
      console.error('Error getting incident stats:', error);
      return DEFAULT_STATS;
    }
  }
};

export default incidentApi;

================
File: client/initialAssessmentApi.js
================
import { delay, validateRequired, checkExists } from '../apiHelpers';
import { mockSystems } from '../mocks/systemMockData';

// In-memory storage for CRUD operations
let systems = [...mockSystems];

const initialAssessmentApi = {
  // Get initial assessment data
  getInitialAssessment: async (clientId, systemId) => {
    await delay(300);
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const numericClientId = Number(clientId);
    const system = systems.find(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(system, 'System');
    return { 
      ...system.phases.initialAssessment,
      lastUpdated: system.updatedAt
    };
  },

  // Update system discovery
  updateSystemDiscovery: async (clientId, systemId, discoveryData) => {
    await delay(500);
    validateRequired({ 
      clientId, 
      systemId,
      ...discoveryData
    }, [
      'clientId',
      'systemId',
      'description',
      'purpose',
      'informationLevel',
    ]);

    const numericClientId = Number(clientId);
    const index = systems.findIndex(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(systems[index], 'System');

    systems[index] = {
      ...systems[index],
      phases: {
        ...systems[index].phases,
        initialAssessment: {
          ...systems[index].phases.initialAssessment,
          discovery: {
            ...discoveryData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    return {
      success: true,
      data: systems[index].phases.initialAssessment.discovery
    };
  },

  // Update environment analysis
  updateEnvironmentAnalysis: async (clientId, systemId, environmentData) => {
    await delay(500);
    validateRequired({ 
      clientId, 
      systemId,
      ...environmentData
    }, [
      'clientId',
      'systemId',
      'hosting',
      'components',
      'networkArchitecture',
      'dependencies',
      'interfaces'
    ]);

    const numericClientId = Number(clientId);
    const index = systems.findIndex(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(systems[index], 'System');

    systems[index] = {
      ...systems[index],
      phases: {
        ...systems[index].phases,
        initialAssessment: {
          ...systems[index].phases.initialAssessment,
          environment: {
            ...environmentData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    return {
      success: true,
      data: systems[index].phases.initialAssessment.environment
    };
  },

  // Update network boundary
  updateNetworkBoundary: async (clientId, systemId, boundaryData) => {
    await delay(500);
    validateRequired({ 
      clientId, 
      systemId,
      ...boundaryData
    }, [
      'clientId',
      'systemId',
      'description',
      'ports',
      'protocols',
      'procedures'
    ]);

    const numericClientId = Number(clientId);
    const index = systems.findIndex(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(systems[index], 'System');

    systems[index] = {
      ...systems[index],
      phases: {
        ...systems[index].phases,
        initialAssessment: {
          ...systems[index].phases.initialAssessment,
          boundary: {
            ...boundaryData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    return {
      success: true,
      data: systems[index].phases.initialAssessment.boundary
    };
  },

  // Update stakeholders
  updateStakeholders: async (clientId, systemId, stakeholderData) => {
    await delay(500);
    validateRequired({ 
      clientId, 
      systemId,
      ...stakeholderData
    }, [
      'clientId',
      'systemId',
      'owners',
      'operators',
      'responsibilities',
      'contacts',
      'communicationChannels'
    ]);

    const numericClientId = Number(clientId);
    const index = systems.findIndex(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(systems[index], 'System');

    systems[index] = {
      ...systems[index],
      phases: {
        ...systems[index].phases,
        initialAssessment: {
          ...systems[index].phases.initialAssessment,
          stakeholders: {
            ...stakeholderData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    return {
      success: true,
      data: systems[index].phases.initialAssessment.stakeholders
    };
  },

  // Get initial assessment progress
  getProgress: async (clientId, systemId) => {
    await delay(300);
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const numericClientId = Number(clientId);
    const system = systems.find(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(system, 'System');

    const sections = [
      system.phases.initialAssessment?.discovery?.status,
      system.phases.initialAssessment?.environment?.status,
      system.phases.initialAssessment?.boundary?.status,
      system.phases.initialAssessment?.stakeholders?.status
    ];

    const completedSections = sections.filter(status => status === 'completed').length;
    const progress = Math.round((completedSections / sections.length) * 100);

    return {
      progress,
      sections: {
        discovery: system.phases.initialAssessment?.discovery?.status || 'not_started',
        environment: system.phases.initialAssessment?.environment?.status || 'not_started',
        boundary: system.phases.initialAssessment?.boundary?.status || 'not_started',
        stakeholders: system.phases.initialAssessment?.stakeholders?.status || 'not_started'
      }
    };
  }
};

export default initialAssessmentApi;

================
File: client/reportGenerationApi.js
================
import { delay } from '../apiHelpers';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';

const reportGenerationApi = {
  generateExecutiveReport: async (data) => {
    await delay(1000); // Simulate processing time

    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    
    // Title
    doc.setFontSize(20);
    doc.text('Executive Security Report', pageWidth / 2, 20, { align: 'center' });
    
    // Client Info
    doc.setFontSize(12);
    doc.text(`Client: ${data.client.name}`, 20, 40);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 50);
    
    // Overall Score
    doc.setFontSize(16);
    doc.text('Overall Security Score', pageWidth / 2, 70, { align: 'center' });
    doc.setFontSize(24);
    doc.text(`${data.overallScore}%`, pageWidth / 2, 85, { align: 'center' });
    
    // Summary Section
    doc.setFontSize(14);
    doc.text('Security Summary', 20, 105);
    doc.setFontSize(10);
    doc.autoTable({
      startY: 110,
      head: [['Category', 'Metric', 'Value']],
      body: [
        ['Assessments', 'Average Score', `${data.summary.assessments.averageScore}%`],
        ['', 'Total Assessments', data.summary.assessments.total],
        ['Findings', 'Open Findings', data.summary.findings.open],
        ['', 'Critical Findings', data.summary.findings.critical],
        ['', 'Total Findings', data.summary.findings.total],
        ['Risks', 'Active Risks', data.summary.risks.active],
        ['', 'High Impact Risks', data.summary.risks.critical],
        ['', 'Total Risks', data.summary.risks.total]
      ]
    });

    // Systems Overview
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Systems Overview', 20, 20);
    doc.setFontSize(10);
    
    const systemsData = data.systems.map(system => [
      system.name,
      system.type,
      system.category,
      system.securityLevel,
      `${system.compliance.nist || 0}%`
    ]);

    doc.autoTable({
      startY: 30,
      head: [['System Name', 'Type', 'Category', 'Security Level', 'NIST Compliance']],
      body: systemsData
    });

    // Risk Analysis
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Risk Analysis', 20, 20);
    doc.setFontSize(10);

    const riskData = data.risks.map(risk => [
      risk.name,
      risk.category,
      risk.impact,
      risk.likelihood,
      risk.status
    ]);

    doc.autoTable({
      startY: 30,
      head: [['Risk Name', 'Category', 'Impact', 'Likelihood', 'Status']],
      body: riskData
    });

    // Recent Activity
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Recent Activity', 20, 20);
    doc.setFontSize(10);

    const activityData = data.recentActivity.map(activity => [
      activity.type,
      activity.title,
      new Date(activity.date).toLocaleDateString(),
      activity.status
    ]);

    doc.autoTable({
      startY: 30,
      head: [['Type', 'Title', 'Date', 'Status']],
      body: activityData
    });

    // Recommendations
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Recommendations', 20, 20);
    doc.setFontSize(10);

    // Generate recommendations based on data
    const recommendations = [
      data.summary.findings.critical > 0 && {
        priority: 'High',
        area: 'Security Findings',
        recommendation: `Address ${data.summary.findings.critical} critical security findings`
      },
      data.summary.risks.active > 0 && {
        priority: 'High',
        area: 'Risk Management',
        recommendation: `Mitigate ${data.summary.risks.active} active security risks`
      },
      data.summary.assessments.averageScore < 80 && {
        priority: 'Medium',
        area: 'Security Assessments',
        recommendation: 'Improve security assessment scores through remediation efforts'
      }
    ].filter(Boolean);

    doc.autoTable({
      startY: 30,
      head: [['Priority', 'Area', 'Recommendation']],
      body: recommendations.map(r => [r.priority, r.area, r.recommendation])
    });

    return doc;
  }
};

export default reportGenerationApi;

================
File: client/reportingApi.js
================
import { delay } from '../apiHelpers';
import auditApi from './auditApi';
import riskAssessmentApi from './riskAssessmentApi';
import securityAssessmentsApi from './securityAssessmentsApi';

const reportingApi = {
  // Get executive dashboard data
  getExecutiveDashboard: async (clientId) => {
    await delay(600);
    const [
      findings,
      risks,
      assessments,
      findingMetrics,
      riskStats
    ] = await Promise.all([
      auditApi.getFindings(clientId),
      riskAssessmentApi.getRisks(clientId),
      securityAssessmentsApi.getAssessments(clientId),
      auditApi.getFindingMetrics(clientId),
      riskAssessmentApi.getRiskStats(clientId)
    ]);

    // Calculate assessment statistics
    const assessmentStats = calculateAssessmentStats(assessments);

    // Calculate overall security score
    const weights = {
      assessmentScore: 0.3,
      findingScore: 0.4,
      riskScore: 0.3
    };

    const assessmentScore = assessmentStats.averageScore;
    const findingScore = calculateFindingScore(findingMetrics);
    const riskScore = calculateRiskScore(riskStats);

    const overallScore = Math.round(
      (assessmentScore * weights.assessmentScore) +
      (findingScore * weights.findingScore) +
      (riskScore * weights.riskScore)
    );

    // Ensure trends data exists with defaults
    const findingTrends = findingMetrics.trends || {
      newFindings: { last30Days: 0, last90Days: 0 },
      closedFindings: { last30Days: 0, last90Days: 0 }
    };

    const riskTrends = riskStats.trends || {
      new: { last30Days: 0, last90Days: 0 },
      mitigated: { last30Days: 0, last90Days: 0 }
    };

    return {
      overallScore,
      summary: {
        assessments: {
          total: assessmentStats.total,
          averageScore: assessmentStats.averageScore,
          lastAssessment: assessmentStats.lastAssessment,
          trend: assessmentStats.scoreHistory
        },
        findings: {
          total: findingMetrics.total,
          open: findingMetrics.byStatus.open,
          critical: findingMetrics.bySeverity.critical + findingMetrics.bySeverity.high,
          trend: findingTrends
        },
        risks: {
          total: riskStats.total,
          active: riskStats.byStatus.active,
          critical: riskStats.byImpact.high,
          trend: riskTrends
        }
      },
      compliance: {
        accessControl: calculateControlCoverage(findings, risks, assessments, 'Access Control'),
        dataProtection: calculateControlCoverage(findings, risks, assessments, 'Data Protection'),
        vulnerabilityManagement: calculateControlCoverage(findings, risks, assessments, 'Vulnerability Management'),
        incidentResponse: calculateControlCoverage(findings, risks, assessments, 'Incident Response')
      },
      trends: {
        last30Days: {
          newFindings: findingTrends.newFindings.last30Days,
          resolvedFindings: findingTrends.closedFindings.last30Days,
          newRisks: riskTrends.new.last30Days,
          mitigatedRisks: riskTrends.mitigated.last30Days,
          assessmentsCompleted: assessmentStats.completedLast30Days
        },
        last90Days: {
          newFindings: findingTrends.newFindings.last90Days,
          resolvedFindings: findingTrends.closedFindings.last90Days,
          newRisks: riskTrends.new.last90Days,
          mitigatedRisks: riskTrends.mitigated.last90Days
        }
      },
      topRisks: risks
        .filter(r => r.status === 'active')
        .sort((a, b) => calculateRiskPriority(b) - calculateRiskPriority(a))
        .slice(0, 5),
      recentActivity: generateRecentActivity(findings, risks, assessments)
    };
  },

  // Get compliance report
  getComplianceReport: async (clientId, framework = 'general') => {
    await delay(600);
    const [findings, risks, assessments] = await Promise.all([
      auditApi.getFindings(clientId),
      riskAssessmentApi.getRisks(clientId),
      securityAssessmentsApi.getAssessments(clientId)
    ]);

    const controls = {
      'Access Control': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Access Control'),
        risks: risks.filter(r => r.category === 'Access Control'),
        assessments: getAssessmentsByCategory(assessments, 'Access Control')
      },
      'Data Protection': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Data Protection'),
        risks: risks.filter(r => r.category === 'Data Protection'),
        assessments: getAssessmentsByCategory(assessments, 'Data Protection')
      },
      'Vulnerability Management': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Vulnerability Management'),
        risks: risks.filter(r => r.category === 'Vulnerability Management'),
        assessments: getAssessmentsByCategory(assessments, 'Vulnerability Management')
      },
      'Incident Response': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Incident Response'),
        risks: risks.filter(r => r.category === 'Incident Response'),
        assessments: getAssessmentsByCategory(assessments, 'Incident Response')
      }
    };

    return {
      framework,
      controls: Object.entries(controls).map(([category, data]) => ({
        category,
        status: calculateControlStatus(data),
        findings: data.findings.length,
        risks: data.risks.length,
        score: calculateControlScore(data),
        gaps: identifyControlGaps(data),
        recommendations: generateControlRecommendations(data)
      }))
    };
  },

  // Get trend analysis
  getTrendAnalysis: async (clientId, period = 90) => {
    await delay(600);
    const [findings, risks, assessments] = await Promise.all([
      auditApi.getFindings(clientId),
      riskAssessmentApi.getRisks(clientId),
      securityAssessmentsApi.getAssessments(clientId)
    ]);

    const startDate = new Date();
    startDate.setDate(startDate.getDate() - period);

    const timelineData = generateTimeline(findings, risks, assessments, startDate);
    const trends = analyzeTrends(timelineData);

    return {
      period,
      timeline: timelineData,
      trends,
      projections: generateProjections(trends)
    };
  }
};

// Helper functions
const calculateAssessmentStats = (assessments) => {
  if (!Array.isArray(assessments)) {
    return {
      total: 0,
      averageScore: 0,
      lastAssessment: null,
      scoreHistory: [],
      completedLast30Days: 0
    };
  }

  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

  const completedAssessments = assessments.filter(a => a.status === 'completed');
  const sortedAssessments = [...assessments].sort((a, b) => new Date(b.date) - new Date(a.date));

  return {
    total: assessments.length,
    averageScore: calculateAverageScore(completedAssessments),
    lastAssessment: sortedAssessments[0] || null,
    scoreHistory: sortedAssessments.map(a => ({
      date: a.date,
      score: a.score || 0,
      type: a.type,
      findings: (a.generatedFindings || []).length
    })),
    completedLast30Days: completedAssessments.filter(
      a => new Date(a.date) >= thirtyDaysAgo
    ).length
  };
};

const calculateFindingScore = (metrics) => {
  const totalFindings = metrics.total;
  if (totalFindings === 0) return 100;

  const weights = {
    critical: 1,
    high: 0.8,
    medium: 0.5,
    low: 0.2
  };

  const weightedOpen = 
    (metrics.bySeverity.critical * weights.critical) +
    (metrics.bySeverity.high * weights.high) +
    (metrics.bySeverity.medium * weights.medium) +
    (metrics.bySeverity.low * weights.low);

  return Math.round(100 - (weightedOpen / totalFindings) * 100);
};

const calculateRiskScore = (stats) => {
  const totalRisks = stats.total;
  if (totalRisks === 0) return 100;

  const weights = {
    high: 1,
    medium: 0.6,
    low: 0.3
  };

  const weightedRisks = 
    (stats.byImpact.high * weights.high) +
    (stats.byImpact.medium * weights.medium) +
    (stats.byImpact.low * weights.low);

  return Math.round(100 - (weightedRisks / totalRisks) * 100);
};

const mapCategoryToControl = (category) => {
  const categoryMap = {
    'System Security': 'Vulnerability Management',
    'Data Protection': 'Data Protection',
    'Access Control': 'Access Control',
    'Audit and Accountability': 'Access Control',
    'Configuration Management': 'Vulnerability Management',
    'System and Information Integrity': 'Vulnerability Management',
    'Incident Response': 'Incident Response'
  };
  return categoryMap[category] || category;
};

const calculateControlCoverage = (findings, risks, assessments, category) => {
  const relevantFindings = findings.filter(f => 
    mapCategoryToControl(f.category) === category
  );
  const relevantRisks = risks.filter(r => r.category === category);
  const relevantAssessments = getAssessmentsByCategory(assessments, category);

  const coverage = {
    findings: {
      total: relevantFindings.length,
      open: relevantFindings.filter(f => f.status === 'open').length,
      inProgress: relevantFindings.filter(f => f.status === 'in_progress').length,
      closed: relevantFindings.filter(f => f.status === 'closed').length
    },
    risks: {
      total: relevantRisks.length,
      active: relevantRisks.filter(r => r.status === 'active').length,
      mitigated: relevantRisks.filter(r => r.status === 'mitigated').length
    },
    assessments: {
      total: relevantAssessments.length,
      averageScore: calculateAverageScore(relevantAssessments)
    }
  };

  return {
    ...coverage,
    score: calculateCoverageScore(coverage)
  };
};

const calculateRiskPriority = (risk) => {
  const impactWeights = { high: 3, medium: 2, low: 1 };
  const likelihoodWeights = { high: 3, medium: 2, low: 1 };
  return impactWeights[risk.impact] * likelihoodWeights[risk.likelihood];
};

const getAssessmentsByCategory = (assessments, category) => {
  return (assessments || []).filter(a => {
    if (!a.answers) return false;

    if (a.type === 'advanced') {
      // For advanced assessments, check specific sections
      switch (category) {
        case 'Access Control':
          return a.answers.ac1 || a.answers.ac2 || a.answers.ac3;
        case 'Data Protection':
          return a.answers.dp1 || a.answers.dp2 || a.answers.dp3;
        case 'Incident Response':
          return a.answers.ir1 || a.answers.ir2 || a.answers.ir3;
        default:
          return false;
      }
    } else {
      // For basic assessments, map question numbers to categories
      const categoryQuestions = {
        'Access Control': [3, 4, 11],
        'Data Protection': [7, 8],
        'Incident Response': [9, 10],
      };
      
      const relevantQuestions = categoryQuestions[category] || [];
      return relevantQuestions.some(q => a.answers[q] === 'yes');
    }
  });
};

const calculateAverageScore = (assessments) => {
  if (!Array.isArray(assessments) || assessments.length === 0) return 0;
  return Math.round(
    assessments.reduce((sum, a) => sum + (a.score || 0), 0) / assessments.length
  );
};

const calculateCoverageScore = (coverage) => {
  const weights = {
    findings: 0.4,
    risks: 0.3,
    assessments: 0.3
  };

  const findingScore = coverage.findings.total === 0 ? 100 :
    Math.round((coverage.findings.closed / coverage.findings.total) * 100);

  const riskScore = coverage.risks.total === 0 ? 100 :
    Math.round((coverage.risks.mitigated / coverage.risks.total) * 100);

  const assessmentScore = coverage.assessments.averageScore;

  return Math.round(
    (findingScore * weights.findings) +
    (riskScore * weights.risks) +
    (assessmentScore * weights.assessments)
  );
};

const calculateControlStatus = (data) => {
  const score = calculateControlScore(data);
  if (score >= 80) return 'effective';
  if (score >= 60) return 'needs_improvement';
  return 'ineffective';
};

const calculateControlScore = (data) => {
  const weights = {
    findings: 0.4,
    risks: 0.3,
    assessments: 0.3
  };

  const findingScore = data.findings.length === 0 ? 100 :
    100 - (data.findings.filter(f => f.status === 'open').length / data.findings.length * 100);

  const riskScore = data.risks.length === 0 ? 100 :
    100 - (data.risks.filter(r => r.status === 'active').length / data.risks.length * 100);

  const assessmentScore = data.assessments.length === 0 ? 0 :
    data.assessments.reduce((sum, a) => sum + (a.score || 0), 0) / data.assessments.length;

  return Math.round(
    (findingScore * weights.findings) +
    (riskScore * weights.risks) +
    (assessmentScore * weights.assessments)
  );
};

const identifyControlGaps = (data) => {
  const gaps = [];

  // Check for critical findings
  const criticalFindings = data.findings.filter(f => 
    f.status === 'open' && (f.severity === 'critical' || f.severity === 'high')
  );
  if (criticalFindings.length > 0) {
    gaps.push({
      type: 'critical_findings',
      count: criticalFindings.length,
      description: 'Open critical/high findings require immediate attention'
    });
  }

  // Check for active high-impact risks
  const highRisks = data.risks.filter(r => 
    r.status === 'active' && r.impact === 'high'
  );
  if (highRisks.length > 0) {
    gaps.push({
      type: 'high_risks',
      count: highRisks.length,
      description: 'Active high-impact risks need mitigation'
    });
  }

  // Check assessment scores
  const lowScoreAssessments = data.assessments.filter(a => 
    (a.score || 0) < 70
  );
  if (lowScoreAssessments.length > 0) {
    gaps.push({
      type: 'low_scores',
      count: lowScoreAssessments.length,
      description: 'Assessments indicate control weaknesses'
    });
  }

  return gaps;
};

const generateControlRecommendations = (data) => {
  const recommendations = [];

  // Analyze findings
  const openFindings = data.findings.filter(f => f.status === 'open');
  if (openFindings.length > 0) {
    const criticalCount = openFindings.filter(f => 
      f.severity === 'critical' || f.severity === 'high'
    ).length;
    
    if (criticalCount > 0) {
      recommendations.push({
        priority: 'high',
        action: 'Address critical findings',
        description: `Remediate ${criticalCount} critical/high findings`
      });
    }
  }

  // Analyze risks
  const activeRisks = data.risks.filter(r => r.status === 'active');
  if (activeRisks.length > 0) {
    const highRiskCount = activeRisks.filter(r => r.impact === 'high').length;
    
    if (highRiskCount > 0) {
      recommendations.push({
        priority: 'high',
        action: 'Mitigate high-impact risks',
        description: `Implement controls for ${highRiskCount} high-impact risks`
      });
    }
  }

  // Analyze assessments
  const recentAssessments = data.assessments
    .sort((a, b) => new Date(b.date) - new Date(a.date))
    .slice(0, 3);

  const averageScore = calculateAverageScore(recentAssessments);
  if (averageScore < 70) {
    recommendations.push({
      priority: 'medium',
      action: 'Improve control effectiveness',
      description: 'Recent assessments indicate need for control improvements'
    });
  }

  return recommendations;
};

const generateTimeline = (findings, risks, assessments, startDate) => {
  const timeline = [];
  const endDate = new Date();

  // Generate daily data points
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const date = d.toISOString().split('T')[0];
    
    const dayFindings = findings.filter(f => 
      f.createdDate.split('T')[0] === date
    );
    
    const dayRisks = risks.filter(r => 
      r.lastAssessed.split('T')[0] === date
    );
    
    const dayAssessments = assessments.filter(a => 
      a.date.split('T')[0] === date
    );

    if (dayFindings.length > 0 || dayRisks.length > 0 || dayAssessments.length > 0) {
      timeline.push({
        date,
        findings: {
          new: dayFindings.length,
          closed: dayFindings.filter(f => f.status === 'closed').length
        },
        risks: {
          new: dayRisks.length,
          mitigated: dayRisks.filter(r => r.status === 'mitigated').length
        },
        assessments: {
          completed: dayAssessments.filter(a => a.status === 'completed').length,
          averageScore: calculateAverageScore(dayAssessments)
        }
      });
    }
  }

  return timeline;
};

const analyzeTrends = (timeline) => {
  const findingsTrend = calculateTrendLine(timeline.map(t => ({
    x: new Date(t.date).getTime(),
    y: t.findings.new - t.findings.closed
  })));

  const risksTrend = calculateTrendLine(timeline.map(t => ({
    x: new Date(t.date).getTime(),
    y: t.risks.new - t.risks.mitigated
  })));

  const assessmentsTrend = calculateTrendLine(timeline.map(t => ({
    x: new Date(t.date).getTime(),
    y: t.assessments.averageScore
  })));

  return {
    findings: findingsTrend,
    risks: risksTrend,
    assessments: assessmentsTrend
  };
};

const calculateTrendLine = (points) => {
  if (points.length < 2) return { slope: 0, direction: 'stable' };

  let sumX = 0;
  let sumY = 0;
  let sumXY = 0;
  let sumXX = 0;
  
  points.forEach(point => {
    sumX += point.x;
    sumY += point.y;
    sumXY += point.x * point.y;
    sumXX += point.x * point.x;
  });

  const n = points.length;
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);

  return {
    slope,
    direction: slope > 0.1 ? 'increasing' : slope < -0.1 ? 'decreasing' : 'stable'
  };
};

const generateProjections = (trends) => {
  return {
    findings: {
      direction: trends.findings.direction,
      impact: trends.findings.slope > 0.5 ? 'high' : 
        trends.findings.slope > 0.2 ? 'medium' : 'low'
    },
    risks: {
      direction: trends.risks.direction,
      impact: trends.risks.slope > 0.5 ? 'high' : 
        trends.risks.slope > 0.2 ? 'medium' : 'low'
    },
    assessments: {
      direction: trends.assessments.direction,
      impact: Math.abs(trends.assessments.slope) > 5 ? 'high' : 
        Math.abs(trends.assessments.slope) > 2 ? 'medium' : 'low'
    }
  };
};

const generateRecentActivity = (findings, risks, assessments) => {
  if (!Array.isArray(findings)) findings = [];
  if (!Array.isArray(risks)) risks = [];
  if (!Array.isArray(assessments)) assessments = [];

  const activities = [
    ...findings.map(f => ({
      type: 'finding',
      date: f.createdDate,
      title: f.title,
      severity: f.severity,
      status: f.status
    })),
    ...risks.map(r => ({
      type: 'risk',
      date: r.lastAssessed,
      title: r.name,
      severity: r.impact,
      status: r.status
    })),
    ...assessments.map(a => ({
      type: 'assessment',
      date: a.date,
      title: a.name,
      score: a.score,
      status: a.status
    }))
  ];

  return activities
    .sort((a, b) => new Date(b.date) - new Date(a.date))
    .slice(0, 10);
};

export default reportingApi;

================
File: client/riskAssessmentApi.js
================
import { delay, getCurrentDate, validateRequired, checkExists } from '../apiHelpers';
import { mockRisks } from '../mocks/riskMockData';

// In-memory storage
let risks = [...mockRisks];

export const riskAssessmentApi = {
  // Get all risks
  getRisks: async (clientId) => {
    await delay(500);
    return risks.filter(risk => risk.clientId === Number(clientId));
  },

  // Get risk by ID
  getRisk: async (clientId, riskId) => {
    await delay(300);
    const risk = risks.find(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risk, 'Risk');
    return { ...risk };
  },

  // Create new risk
  createRisk: async (clientId, riskData) => {
    await delay(800);
    validateRequired(riskData, ['name', 'description', 'impact', 'likelihood', 'category']);

    const newRisk = {
      id: `r-${Date.now()}`,
      clientId: Number(clientId),
      lastAssessed: getCurrentDate(),
      sourceFindings: [],
      businessImpact: {
        financial: '',
        operational: '',
        reputational: '',
        compliance: ''
      },
      treatment: {
        approach: 'mitigate',
        plan: '',
        status: 'not_started',
        objectives: []
      },
      ...riskData
    };

    risks.push(newRisk);
    return { ...newRisk };
  },

  // Update risk
  updateRisk: async (clientId, riskId, updates) => {
    await delay(500);
    const index = risks.findIndex(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risks[index], 'Risk');

    risks[index] = {
      ...risks[index],
      ...updates,
      lastAssessed: getCurrentDate()
    };

    return { ...risks[index] };
  },

  // Delete risk
  deleteRisk: async (clientId, riskId) => {
    await delay(800);
    const index = risks.findIndex(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risks[index], 'Risk');

    risks = risks.filter(r => !(r.clientId === Number(clientId) && r.id === riskId));
    return { success: true };
  },

  // Add finding to risk
  addFindingToRisk: async (clientId, riskId, findingData) => {
    await delay(500);
    const index = risks.findIndex(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risks[index], 'Risk');

    validateRequired(findingData, ['findingId', 'title', 'sourceType']);

    risks[index].sourceFindings = [
      ...(risks[index].sourceFindings || []),
      {
        ...findingData,
        date: getCurrentDate()
      }
    ];

    return { ...risks[index] };
  },

  // Remove finding from risk
  removeFindingFromRisk: async (clientId, riskId, findingId) => {
    await delay(500);
    const index = risks.findIndex(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risks[index], 'Risk');

    risks[index].sourceFindings = risks[index].sourceFindings.filter(f => f.findingId !== findingId);

    return { ...risks[index] };
  },

  // Update risk treatment
  updateRiskTreatment: async (clientId, riskId, treatmentData) => {
    await delay(500);
    const index = risks.findIndex(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risks[index], 'Risk');

    validateRequired(treatmentData, ['approach', 'plan']);

    risks[index].treatment = {
      ...risks[index].treatment,
      ...treatmentData,
      lastUpdated: getCurrentDate()
    };

    return { ...risks[index] };
  },

  // Link objective to risk treatment
  linkObjectiveToRisk: async (clientId, riskId, objectiveId) => {
    await delay(500);
    const index = risks.findIndex(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risks[index], 'Risk');

    if (!risks[index].treatment.objectives) {
      risks[index].treatment.objectives = [];
    }

    if (!risks[index].treatment.objectives.includes(objectiveId)) {
      risks[index].treatment.objectives.push(objectiveId);
    }

    return { ...risks[index] };
  },

  // Unlink objective from risk treatment
  unlinkObjectiveFromRisk: async (clientId, riskId, objectiveId) => {
    await delay(500);
    const index = risks.findIndex(r => r.clientId === Number(clientId) && r.id === riskId);
    checkExists(risks[index], 'Risk');

    if (risks[index].treatment.objectives) {
      risks[index].treatment.objectives = risks[index].treatment.objectives.filter(id => id !== objectiveId);
    }

    return { ...risks[index] };
  },

  // Get risk statistics
  getRiskStats: async (clientId) => {
    await delay(400);
    const clientRisks = risks.filter(risk => risk.clientId === Number(clientId));

    return {
      total: clientRisks.length,
      byImpact: {
        high: clientRisks.filter(r => r.impact === 'high').length,
        medium: clientRisks.filter(r => r.impact === 'medium').length,
        low: clientRisks.filter(r => r.impact === 'low').length
      },
      byLikelihood: {
        high: clientRisks.filter(r => r.likelihood === 'high').length,
        medium: clientRisks.filter(r => r.likelihood === 'medium').length,
        low: clientRisks.filter(r => r.likelihood === 'low').length
      },
      byStatus: {
        active: clientRisks.filter(r => r.status === 'active').length,
        mitigated: clientRisks.filter(r => r.status === 'mitigated').length,
        accepted: clientRisks.filter(r => r.status === 'accepted').length,
        transferred: clientRisks.filter(r => r.status === 'transferred').length
      },
      byTreatment: {
        not_started: clientRisks.filter(r => r.treatment?.status === 'not_started').length,
        in_progress: clientRisks.filter(r => r.treatment?.status === 'in_progress').length,
        completed: clientRisks.filter(r => r.treatment?.status === 'completed').length,
        blocked: clientRisks.filter(r => r.treatment?.status === 'blocked').length
      },
      sourceAnalysis: {
        fromFindings: clientRisks.filter(r => r.sourceFindings?.length > 0).length,
        manuallyIdentified: clientRisks.filter(r => !r.sourceFindings?.length).length,
        bySourceType: {
          security_assessment: clientRisks.filter(r => 
            r.sourceFindings?.some(f => f.sourceType === 'security_assessment')
          ).length,
          vulnerability_scan: clientRisks.filter(r => 
            r.sourceFindings?.some(f => f.sourceType === 'vulnerability_scan')
          ).length,
          external_audit: clientRisks.filter(r => 
            r.sourceFindings?.some(f => f.sourceType === 'external_audit')
          ).length
        }
      }
    };
  },

  // Get framework progress
  getFrameworkProgress: async (clientId) => {
    await delay(400);
    const clientRisks = risks.filter(risk => risk.clientId === Number(clientId));

    return {
      riskManagement: {
        identified: clientRisks.length,
        assessed: clientRisks.filter(r => r.impact && r.likelihood).length,
        treated: clientRisks.filter(r => r.treatment?.plan).length,
        mitigated: clientRisks.filter(r => r.status === 'mitigated').length
      },
      coverage: {
        accessControl: clientRisks.filter(r => r.category === 'Access Control').length,
        dataProtection: clientRisks.filter(r => r.category === 'Data Protection').length,
        vulnerabilityManagement: clientRisks.filter(r => r.category === 'Vulnerability Management').length,
        thirdPartyRisk: clientRisks.filter(r => r.category === 'Third Party Risk').length,
        businessContinuity: clientRisks.filter(r => r.category === 'Business Continuity').length,
        compliance: clientRisks.filter(r => r.category === 'Compliance').length
      },
      trends: {
        newRisks: {
          last30Days: clientRisks.filter(r => 
            new Date(r.lastAssessed) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
          ).length,
          last90Days: clientRisks.filter(r => 
            new Date(r.lastAssessed) > new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)
          ).length
        },
        mitigatedRisks: {
          last30Days: clientRisks.filter(r => 
            r.status === 'mitigated' && 
            new Date(r.lastAssessed) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
          ).length,
          last90Days: clientRisks.filter(r => 
            r.status === 'mitigated' && 
            new Date(r.lastAssessed) > new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)
          ).length
        }
      }
    };
  }
};

export default riskAssessmentApi;

================
File: client/securityAssessmentsApi.js
================
import { validateRequired } from '../apiHelpers';

const API_URL = 'http://localhost:3001';

export const securityAssessmentsApi = {
  // Get all assessments for a client
  getAssessments: async (clientId, options = {}) => {
    validateRequired({ clientId }, ['clientId']);
    
    const response = await fetch(`${API_URL}/assessmentHistory?clientId=${clientId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch assessments');
    }
    let assessments = await response.json();

    // Apply filters
    if (options.status && options.status !== 'all') {
      assessments = assessments.filter(a => a.status === options.status);
    }
    if (options.type && options.type !== 'all') {
      assessments = assessments.filter(a => a.type === options.type);
    }
    if (options.dateRange) {
      const { start, end } = options.dateRange;
      assessments = assessments.filter(a => {
        const assessmentDate = new Date(a.date);
        return assessmentDate >= new Date(start) && assessmentDate <= new Date(end);
      });
    }

    // Apply sorting
    if (options.sortBy) {
      assessments.sort((a, b) => {
        switch (options.sortBy) {
          case 'date':
            return new Date(b.date) - new Date(a.date);
          case 'score':
            return (b.score || 0) - (a.score || 0);
          default:
            return 0;
        }
      });
    }

    return assessments;
  },

  // Get assessment by ID
  getAssessment: async (assessmentId) => {
    validateRequired({ assessmentId }, ['assessmentId']);
    const response = await fetch(`${API_URL}/assessmentHistory/${assessmentId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch assessment');
    }
    return response.json();
  },

  // Get findings for an assessment
  getFindings: async (assessmentId) => {
    validateRequired({ assessmentId }, ['assessmentId']);
    const response = await fetch(`${API_URL}/assessmentHistory/${assessmentId}/generatedFindings`);
    if (!response.ok) {
      throw new Error('Failed to fetch findings');
    }
    return response.json();
  },

  // Submit a new assessment
  submitAssessment: async (clientId, assessmentData) => {
    validateRequired(assessmentData, ['type', 'name', 'answers']);
    
    const response = await fetch(`${API_URL}/assessmentHistory`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        clientId: Number(clientId),
        date: new Date().toISOString(),
        status: 'pending_review',
        ...assessmentData
      })
    });

    if (!response.ok) {
      throw new Error('Failed to submit assessment');
    }

    return response.json();
  },

  // Update assessment status
  updateAssessmentStatus: async (assessmentId, status) => {
    validateRequired({ assessmentId, status }, ['assessmentId', 'status']);
    
    const response = await fetch(`${API_URL}/assessmentHistory/${assessmentId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        status,
        lastUpdated: new Date().toISOString()
      })
    });

    if (!response.ok) {
      throw new Error('Failed to update assessment status');
    }

    return response.json();
  },

  // Review assessment
  reviewAssessment: async (assessmentId, reviewData) => {
    validateRequired(reviewData, ['reviewer', 'status']);
    
    const response = await fetch(`${API_URL}/assessmentHistory/${assessmentId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        reviewer: reviewData.reviewer,
        status: reviewData.status,
        reviewNotes: reviewData.notes,
        reviewDate: new Date().toISOString()
      })
    });

    if (!response.ok) {
      throw new Error('Failed to review assessment');
    }

    return response.json();
  }
};

export default securityAssessmentsApi;

================
File: client/securityInitiativesApi.js
================
import { delay, validateRequired, checkExists } from '../apiHelpers';
import {
  mockInitiatives,
  mockInitiativeStatus,
  mockPhases
} from '../mocks/securityInitiativesMockData';

// In-memory storage
let initiatives = [...mockInitiatives];

const securityInitiativesApi = {
  // Get all initiatives for a client
  getInitiatives: async (clientId) => {
    await delay(500);
    const numericClientId = Number(clientId);
    return initiatives
      .filter(init => init.clientId === numericClientId)
      .map(init => ({ ...init }));
  },

  // Get initiatives by objective
  getInitiativesByObjective: async (clientId, objectiveId) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericObjectiveId = Number(objectiveId);
    return initiatives
      .filter(init => init.clientId === numericClientId && init.objectiveId === numericObjectiveId)
      .map(init => ({ ...init }));
  },

  // Get single initiative
  getInitiative: async (clientId, initiativeId) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericInitiativeId = Number(initiativeId);
    const initiative = initiatives.find(
      init => init.clientId === numericClientId && init.id === numericInitiativeId
    );
    checkExists(initiative, 'Security Initiative');
    return { ...initiative };
  },

  // Create new initiative
  createInitiative: async (clientId, initiativeData) => {
    await delay(500);
    validateRequired(initiativeData, ['name', 'phase', 'timeline', 'objectiveId']);

    if (!mockPhases.includes(initiativeData.phase)) {
      throw new Error('Invalid phase');
    }

    if (!initiativeData.status) {
      initiativeData.status = 'Planning';
    } else if (!mockInitiativeStatus.includes(initiativeData.status)) {
      throw new Error('Invalid status');
    }

    const newInitiative = {
      id: Math.max(0, ...initiatives.map(init => init.id)) + 1,
      clientId: Number(clientId),
      objectiveId: Number(initiativeData.objectiveId),
      milestones: [],
      resources: {
        team: [],
        budget: '0',
        tools: []
      },
      ...initiativeData
    };

    initiatives.push(newInitiative);
    return { ...newInitiative };
  },

  // Update initiative
  updateInitiative: async (clientId, initiativeId, updates) => {
    await delay(500);
    const numericClientId = Number(clientId);
    const numericInitiativeId = Number(initiativeId);
    const index = initiatives.findIndex(
      init => init.clientId === numericClientId && init.id === numericInitiativeId
    );
    checkExists(initiatives[index], 'Security Initiative');

    if (updates.phase && !mockPhases.includes(updates.phase)) {
      throw new Error('Invalid phase');
    }

    if (updates.status && !mockInitiativeStatus.includes(updates.status)) {
      throw new Error('Invalid status');
    }

    // Convert objectiveId if it's being updated
    if (updates.objectiveId) {
      updates.objectiveId = Number(updates.objectiveId);
    }

    initiatives[index] = {
      ...initiatives[index],
      ...updates
    };

    return { ...initiatives[index] };
  },

  // Delete initiative
  deleteInitiative: async (clientId, initiativeId) => {
    await delay(500);
    const numericClientId = Number(clientId);
    const numericInitiativeId = Number(initiativeId);
    const index = initiatives.findIndex(
      init => init.clientId === numericClientId && init.id === numericInitiativeId
    );
    checkExists(initiatives[index], 'Security Initiative');

    initiatives = initiatives.filter(init => !(init.clientId === numericClientId && init.id === numericInitiativeId));
    return { success: true, message: 'Security initiative deleted successfully' };
  },

  // Add milestone
  addMilestone: async (clientId, initiativeId, milestoneData) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericInitiativeId = Number(initiativeId);
    const index = initiatives.findIndex(
      init => init.clientId === numericClientId && init.id === numericInitiativeId
    );
    checkExists(initiatives[index], 'Security Initiative');

    validateRequired(milestoneData, ['name']);

    const newMilestone = {
      id: Math.max(0, ...initiatives[index].milestones.map(m => m.id)) + 1,
      completed: false,
      ...milestoneData
    };

    initiatives[index].milestones.push(newMilestone);
    return { ...newMilestone };
  },

  // Update milestone
  updateMilestone: async (clientId, initiativeId, milestoneId, updates) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericInitiativeId = Number(initiativeId);
    const numericMilestoneId = Number(milestoneId);
    const initiativeIndex = initiatives.findIndex(
      init => init.clientId === numericClientId && init.id === numericInitiativeId
    );
    checkExists(initiatives[initiativeIndex], 'Security Initiative');

    const milestoneIndex = initiatives[initiativeIndex].milestones.findIndex(
      m => m.id === numericMilestoneId
    );
    checkExists(initiatives[initiativeIndex].milestones[milestoneIndex], 'Milestone');

    initiatives[initiativeIndex].milestones[milestoneIndex] = {
      ...initiatives[initiativeIndex].milestones[milestoneIndex],
      ...updates
    };

    return { ...initiatives[initiativeIndex].milestones[milestoneIndex] };
  },

  // Delete milestone
  deleteMilestone: async (clientId, initiativeId, milestoneId) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericInitiativeId = Number(initiativeId);
    const numericMilestoneId = Number(milestoneId);
    const initiativeIndex = initiatives.findIndex(
      init => init.clientId === numericClientId && init.id === numericInitiativeId
    );
    checkExists(initiatives[initiativeIndex], 'Security Initiative');

    const milestoneIndex = initiatives[initiativeIndex].milestones.findIndex(
      m => m.id === numericMilestoneId
    );
    checkExists(initiatives[initiativeIndex].milestones[milestoneIndex], 'Milestone');

    initiatives[initiativeIndex].milestones = initiatives[initiativeIndex].milestones.filter(
      m => m.id !== numericMilestoneId
    );

    return { success: true, message: 'Milestone deleted successfully' };
  },

  // Update resources
  updateResources: async (clientId, initiativeId, resources) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericInitiativeId = Number(initiativeId);
    const index = initiatives.findIndex(
      init => init.clientId === numericClientId && init.id === numericInitiativeId
    );
    checkExists(initiatives[index], 'Security Initiative');

    validateRequired(resources, ['team', 'budget', 'tools']);

    initiatives[index].resources = {
      ...initiatives[index].resources,
      ...resources
    };

    return { ...initiatives[index] };
  },

  // Get initiative statuses
  getInitiativeStatuses: async () => {
    await delay(200);
    return [...mockInitiativeStatus];
  },

  // Get phases
  getPhases: async () => {
    await delay(200);
    return [...mockPhases];
  }
};

export default securityInitiativesApi;

================
File: client/securityObjectivesApi.js
================
import { delay, validateRequired, checkExists } from '../apiHelpers';
import {
  mockObjectives,
  mockObjectiveStatus,
  mockPriorityLevels
} from '../mocks/securityObjectivesMockData';

// In-memory storage
let objectives = [...mockObjectives];

const securityObjectivesApi = {
  // Get all objectives for a client
  getObjectives: async (clientId) => {
    await delay(500);
    const numericClientId = Number(clientId);
    return objectives
      .filter(obj => obj.clientId === numericClientId)
      .map(obj => ({ ...obj }));
  },

  // Get single objective
  getObjective: async (clientId, objectiveId) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericObjectiveId = Number(objectiveId);
    const objective = objectives.find(
      obj => obj.clientId === numericClientId && obj.id === numericObjectiveId
    );
    checkExists(objective, 'Security Objective');
    return { ...objective };
  },

  // Create new objective
  createObjective: async (clientId, objectiveData) => {
    await delay(500);
    validateRequired(objectiveData, ['name', 'priority', 'dueDate']);

    if (!mockPriorityLevels.includes(objectiveData.priority)) {
      throw new Error('Invalid priority level');
    }

    if (!objectiveData.status) {
      objectiveData.status = 'Planning';
    } else if (!mockObjectiveStatus.includes(objectiveData.status)) {
      throw new Error('Invalid status');
    }

    const newObjective = {
      id: Math.max(0, ...objectives.map(obj => obj.id)) + 1,
      clientId: Number(clientId),
      progress: 0,
      metrics: {
        successCriteria: [],
        currentMetrics: []
      },
      ...objectiveData
    };

    objectives.push(newObjective);
    return { ...newObjective };
  },

  // Update objective
  updateObjective: async (clientId, objectiveId, updates) => {
    await delay(500);
    const numericClientId = Number(clientId);
    const numericObjectiveId = Number(objectiveId);
    const index = objectives.findIndex(
      obj => obj.clientId === numericClientId && obj.id === numericObjectiveId
    );
    checkExists(objectives[index], 'Security Objective');

    if (updates.priority && !mockPriorityLevels.includes(updates.priority)) {
      throw new Error('Invalid priority level');
    }

    if (updates.status && !mockObjectiveStatus.includes(updates.status)) {
      throw new Error('Invalid status');
    }

    objectives[index] = {
      ...objectives[index],
      ...updates
    };

    return { ...objectives[index] };
  },

  // Delete objective
  deleteObjective: async (clientId, objectiveId) => {
    await delay(500);
    const numericClientId = Number(clientId);
    const numericObjectiveId = Number(objectiveId);
    const index = objectives.findIndex(
      obj => obj.clientId === numericClientId && obj.id === numericObjectiveId
    );
    checkExists(objectives[index], 'Security Objective');

    objectives = objectives.filter(obj => !(obj.clientId === numericClientId && obj.id === numericObjectiveId));
    return { success: true, message: 'Security objective deleted successfully' };
  },

  // Update objective metrics
  updateObjectiveMetrics: async (clientId, objectiveId, metrics) => {
    await delay(300);
    const numericClientId = Number(clientId);
    const numericObjectiveId = Number(objectiveId);
    const index = objectives.findIndex(
      obj => obj.clientId === numericClientId && obj.id === numericObjectiveId
    );
    checkExists(objectives[index], 'Security Objective');

    validateRequired(metrics, ['successCriteria', 'currentMetrics']);

    objectives[index].metrics = {
      ...objectives[index].metrics,
      ...metrics
    };

    return { ...objectives[index] };
  },

  // Get objective statuses
  getObjectiveStatuses: async () => {
    await delay(200);
    return [...mockObjectiveStatus];
  },

  // Get priority levels
  getPriorityLevels: async () => {
    await delay(200);
    return [...mockPriorityLevels];
  }
};

export default securityObjectivesApi;

================
File: grc_application/grcUserApi.js
================
import { validateRequired, validateEmail, ApiError } from '../apiHelpers';

const API_URL = 'http://localhost:3001';

// Login GRC user
export const login = async ({ email, password }) => {
  validateRequired({ email, password }, ['email', 'password']);
  validateEmail(email);

  // Find user by email
  const response = await fetch(`${API_URL}/users?email=${email}`);
  const users = await response.json();
  const user = users[0];

  if (!user || user.password !== password) {
    throw new ApiError('Invalid email or password', 401);
  }

  if (!user.isActive) {
    throw new ApiError('Account is inactive', 403);
  }

  // Generate a mock token
  const token = `grc-token-${Date.now()}`;

  // Update last active timestamp
  await fetch(`${API_URL}/users/${user.id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      lastActive: new Date().toISOString()
    })
  });

  // Return user data without sensitive information
  // eslint-disable-next-line no-unused-vars
  const { password: _password, ...userWithoutPassword } = user;
  return {
    user: userWithoutPassword,
    token
  };
};

// Get all GRC users
export const getGrcUsers = async () => {
  const response = await fetch(`${API_URL}/users`);
  const users = await response.json();
  return users.map(user => {
    // eslint-disable-next-line no-unused-vars
    const { password: _password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  });
};

// Create new GRC user
export const createGrcUser = async (userData) => {
  validateRequired(userData, ['email', 'password', 'firstName', 'lastName', 'role']);
  validateEmail(userData.email);

  // Validate role exists
  const rolesResponse = await fetch(`${API_URL}/roles`);
  const roles = await rolesResponse.json();
  if (!roles[userData.role]) {
    throw new ApiError('Invalid role specified', 400);
  }

  // Check for existing email
  const existingResponse = await fetch(`${API_URL}/users?email=${userData.email}`);
  const existingUsers = await existingResponse.json();
  if (existingUsers.length > 0) {
    throw new ApiError('Email already exists', 400);
  }

  // Create new user
  const response = await fetch(`${API_URL}/users`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ...userData,
      isActive: true,
      lastActive: new Date().toISOString(),
      lastLogin: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      failedLoginAttempts: 0,
      lastPasswordChange: new Date().toISOString(),
      preferences: {
        notifications: true,
        theme: 'light',
        language: 'en'
      }
    })
  });

  const newUser = await response.json();
  // eslint-disable-next-line no-unused-vars
  const { password: _password, ...userWithoutPassword } = newUser;
  return userWithoutPassword;
};

// Update GRC user
export const updateGrcUser = async (id, updates) => {
  // Check if user exists
  const userResponse = await fetch(`${API_URL}/users/${id}`);
  if (!userResponse.ok) {
    throw new ApiError('GRC User not found', 404);
  }

  if (updates.email) {
    validateEmail(updates.email);
    // Check if email is taken by another user
    const existingResponse = await fetch(`${API_URL}/users?email=${updates.email}&id_ne=${id}`);
    const existingUsers = await existingResponse.json();
    if (existingUsers.length > 0) {
      throw new ApiError('Email already exists', 400);
    }
  }

  if (updates.role) {
    const rolesResponse = await fetch(`${API_URL}/roles`);
    const roles = await rolesResponse.json();
    if (!roles[updates.role]) {
      throw new ApiError('Invalid role specified', 400);
    }
  }

  const response = await fetch(`${API_URL}/users/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ...updates,
      updatedAt: new Date().toISOString()
    })
  });

  const updatedUser = await response.json();
  const { ...userWithoutPassword } = updatedUser;
  return userWithoutPassword;
};

// Get available GRC roles
export const getGrcRoles = async () => {
  const response = await fetch(`${API_URL}/roles`);
  const roles = await response.json();
  return Object.keys(roles);
};

// Get GRC user by ID
export const getGrcUser = async (id) => {
  const response = await fetch(`${API_URL}/users/${id}`);
  if (!response.ok) {
    throw new ApiError('GRC User not found', 404);
  }
  
  const user = await response.json();
  // eslint-disable-next-line no-unused-vars
  const { password: _password, ...userWithoutPassword } = user;
  return userWithoutPassword;
};

// Check if GRC user has specific permission
export const hasPermission = async (userId, permission) => {
  // Get user
  const userResponse = await fetch(`${API_URL}/users/${userId}`);
  if (!userResponse.ok) return false;
  const user = await userResponse.json();

  // Get role permissions
  const rolesResponse = await fetch(`${API_URL}/roles`);
  const roles = await rolesResponse.json();
  const userRole = roles[user.role];

  if (!userRole) return false;

  // Senior AOs have all permissions
  if (user.role === 'SENIOR_AO') return true;

  return userRole.permissions.includes(permission) || userRole.permissions.includes('all');
};

// Export all functions as a default object
const grcUserApi = {
  login,
  getGrcUsers,
  createGrcUser,
  updateGrcUser,
  getGrcRoles,
  getGrcUser,
  hasPermission
};

export default grcUserApi;

================
File: grc_application/settingsApi.js
================
import { delay, ApiError } from '../apiHelpers';

// In-memory storage for settings
let systemSettings = {
  s3: {
    enabled: false,
    region: '',
    accessKeyId: '',
    secretAccessKey: '',
    defaultBucket: '',
    buckets: []
  }
};

const settingsApi = {
  // Get all system settings
  getSettings: async () => {
    await delay(300);
    return { ...systemSettings };
  },

  // Update S3 configuration
  updateS3Config: async (config) => {
    await delay(500);
    
    // Validate required fields
    const requiredFields = ['region', 'accessKeyId', 'secretAccessKey'];
    for (const field of requiredFields) {
      if (!config[field]) {
        throw new ApiError(`${field} is required`, 400);
      }
    }

    // In a real implementation, we would validate the credentials here
    // For now, we'll simulate a connection test
    await delay(1000); // Simulate AWS SDK validation

    systemSettings.s3 = {
      ...systemSettings.s3,
      ...config,
      enabled: true
    };

    return { 
      success: true, 
      message: 'S3 configuration updated successfully',
      config: { ...systemSettings.s3 }
    };
  },

  // Test S3 connection
  testS3Connection: async () => {
    await delay(800);
    
    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    // In a real implementation, we would test the connection here
    // For now, we'll simulate a successful connection
    return {
      success: true,
      message: 'Successfully connected to S3'
    };
  },

  // List S3 buckets
  listS3Buckets: async () => {
    await delay(500);

    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    // In a real implementation, we would fetch buckets from AWS
    // For now, return mock buckets
    return [
      { name: 'grc-documents', region: systemSettings.s3.region, createdAt: '2024-01-01T00:00:00Z' },
      { name: 'grc-backups', region: systemSettings.s3.region, createdAt: '2024-01-01T00:00:00Z' }
    ];
  },

  // Create new S3 bucket
  createS3Bucket: async (bucketName) => {
    await delay(800);

    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    if (!bucketName) {
      throw new ApiError('Bucket name is required', 400);
    }

    // Validate bucket name (simplified AWS S3 bucket naming rules)
    const bucketNameRegex = /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/;
    if (!bucketNameRegex.test(bucketName)) {
      throw new ApiError('Invalid bucket name. Must be 3-63 characters, lowercase, numbers, hyphens', 400);
    }

    // In a real implementation, we would create the bucket in AWS
    const newBucket = {
      name: bucketName,
      region: systemSettings.s3.region,
      createdAt: new Date().toISOString()
    };

    systemSettings.s3.buckets.push(newBucket);

    return {
      success: true,
      message: 'Bucket created successfully',
      bucket: { ...newBucket }
    };
  },

  // Set default S3 bucket
  setDefaultBucket: async (bucketName) => {
    await delay(300);

    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    if (!bucketName) {
      throw new ApiError('Bucket name is required', 400);
    }

    // In a real implementation, we would verify the bucket exists in AWS
    systemSettings.s3.defaultBucket = bucketName;

    return {
      success: true,
      message: 'Default bucket updated successfully',
      defaultBucket: bucketName
    };
  }
};

export default settingsApi;

================
File: index.js
================
// Client APIs
export { default as assessmentApi } from './client/assessmentApi';
export { default as auditApi } from './client/auditApi';
export { default as clientApi } from './client/clientApi';
export { default as clientUserApi } from './client/clientUserApi';
export { default as incidentApi } from './client/incidentApi';
export { default as initialAssessmentApi } from './client/initialAssessmentApi';
export { default as reportGenerationApi } from './client/reportGenerationApi';
export { default as reportingApi } from './client/reportingApi';
export { default as riskAssessmentApi } from './client/riskAssessmentApi';
export { default as securityAssessmentsApi } from './client/securityAssessmentsApi';
export { default as securityInitiativesApi } from './client/securityInitiativesApi';
export { default as securityObjectivesApi } from './client/securityObjectivesApi';

// System APIs
export { default as artifactsApi } from './system/artifactsApi';
export { default as atoTrackerApi } from './system/atoTrackerApi';
export { default as authorizationApi } from './system/authorizationApi';
export { systemApi, SecurityLevel, InformationLevel, SystemCategory } from './system/systemApi';
export { default as systemCategorizationApi } from './system/systemCategorizationApi';
export { default as systemComponentsApi } from './system/systemComponentsApi';
export { default as systemControlsApi } from './system/systemControlsApi';

// GRC Application APIs
export { default as grcUserApi } from './grc_application/grcUserApi';
export { default as settingsApi } from './grc_application/settingsApi';

// Default export for systemApi
export { default } from './system/systemApi';

================
File: mocks/artifactsMockData.js
================
export const artifactsMockData = [
  {
    id: "art-001",
    name: "System Architecture Diagram",
    type: "Technical Documentation",
    uploadDate: "2024-02-21T08:00:00Z",
    description: "Detailed system architecture diagram showing all components and their interactions",
    fileUrl: "/artifacts/system-architecture.pdf",
    fileType: "application/pdf",
    size: 2457600, // 2.4MB
    uploadedBy: "John Smith"
  },
  {
    id: "art-002",
    name: "Security Policy Document",
    type: "Policy Documentation",
    uploadDate: "2024-02-20T15:30:00Z",
    description: "Organization's security policies and procedures",
    fileUrl: "/artifacts/security-policy-v1.docx",
    fileType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    size: 1048576, // 1MB
    uploadedBy: "Sarah Johnson"
  },
  {
    id: "art-003",
    name: "Vulnerability Scan Results",
    type: "Security Assessment",
    uploadDate: "2024-02-19T11:15:00Z",
    description: "Latest vulnerability scan results from Nessus",
    fileUrl: "/artifacts/vuln-scan-feb2024.pdf",
    fileType: "application/pdf",
    size: 3145728, // 3MB
    uploadedBy: "Mike Wilson"
  },
  {
    id: "art-004",
    name: "Network Diagram",
    type: "Technical Documentation",
    uploadDate: "2024-02-18T09:45:00Z",
    description: "Current network topology and configuration",
    fileUrl: "/artifacts/network-diagram.png",
    fileType: "image/png",
    size: 512000, // 500KB
    uploadedBy: "John Smith"
  },
  {
    id: "art-005",
    name: "Security Control Implementation",
    type: "Implementation Evidence",
    uploadDate: "2024-02-17T14:20:00Z",
    description: "Screenshots and configuration files showing security control implementation",
    fileUrl: "/artifacts/control-implementation.zip",
    fileType: "application/zip",
    size: 5242880, // 5MB
    uploadedBy: "Sarah Johnson"
  }
];

export const artifactTypes = [
  "Technical Documentation",
  "Policy Documentation",
  "Security Assessment",
  "Implementation Evidence",
  "Training Records",
  "Audit Reports",
  "Configuration Files",
  "System Logs",
  "Incident Reports",
  "Other"
];

================
File: mocks/assessmentMockData.js
================
const mockAssessmentData = {
  assessmentPlan: {
    id: 'ap-001',
    assessmentTitle: 'Annual Security Assessment 2025',
    assessmentType: 'Annual Assessment',
    startDate: '2025-01-01',
    endDate: '2025-03-31',
    assessmentTeam: 'Security Team A\nExternal Auditor: SecureAudit Inc.',
    objectives: 'Evaluate system security controls\nValidate compliance with security requirements\nIdentify potential vulnerabilities',
    methodology: 'NIST SP 800-53A Rev 5\nAutomated scanning\nManual testing\nDocument review',
    scope: 'All production systems\nNetwork infrastructure\nAccess controls\nSecurity policies',
    requirements: 'NIST 800-53 Low baseline\nOrganizational security policies\nRegulatory requirements',
    status: 'in-progress',
  },

  scanResults: [
    {
      id: 'scan-001',
      type: 'STIG Scan',
      date: '2025-02-15T10:00:00Z',
      findings: {
        high: 2,
        medium: 5,
        low: 8,
      },
      status: 'Completed',
      downloadUrl: '#',
      detailsUrl: '#',
    },
    {
      id: 'scan-002',
      type: 'SCAP Scan',
      date: '2025-02-01T14:30:00Z',
      findings: {
        high: 1,
        medium: 3,
        low: 6,
      },
      status: 'Completed',
      downloadUrl: '#',
      detailsUrl: '#',
    },
  ],

  controls: [
    {
      id: 'AC-1',
      title: 'Access Control Policy and Procedures',
      status: 'Compliant',
      evidence: 'Access Control Policy v2.1 implemented and reviewed',
      notes: 'Annual review completed',
      lastUpdated: '2025-02-10T09:00:00Z',
    },
    {
      id: 'AC-2',
      title: 'Account Management',
      status: 'Non-Compliant',
      evidence: 'Automated account review process not implemented',
      notes: 'Implementation in progress',
      lastUpdated: '2025-02-11T15:30:00Z',
    },
    {
      id: 'AC-3',
      title: 'Access Enforcement',
      status: 'Compliant',
      evidence: 'Role-based access control implemented',
      notes: 'Verified during testing',
      lastUpdated: '2025-02-12T11:20:00Z',
    },
    {
      id: 'AC-4',
      title: 'Information Flow Enforcement',
      status: 'Not-Applicable',
      evidence: 'System does not process classified information',
      notes: 'Approved deviation',
      lastUpdated: '2025-02-13T14:15:00Z',
    },
  ],

  documents: [
    {
      id: 'doc-001',
      name: 'System Security Plan',
      expirationDate: '2026-02-20',
      lastReviewed: '2025-02-15',
      validationNotes: 'Annual review completed. Updates required for new controls.',
      reviewHistory: [
        {
          date: '2025-02-15',
          notes: 'Annual review completed. Updates required for new controls.',
        },
        {
          date: '2024-02-15',
          notes: 'Initial review completed.',
        },
      ],
    },
    {
      id: 'doc-002',
      name: 'Incident Response Plan',
      expirationDate: '2025-03-15',
      lastReviewed: '2024-03-15',
      validationNotes: 'Review needed before expiration',
      reviewHistory: [
        {
          date: '2024-03-15',
          notes: 'Annual review completed. No major changes required.',
        },
      ],
    },
    {
      id: 'doc-003',
      name: 'Contingency Plan',
      expirationDate: '2025-01-10',
      lastReviewed: '2024-01-10',
      validationNotes: 'Document expired. Immediate review required.',
      reviewHistory: [
        {
          date: '2024-01-10',
          notes: 'Annual review completed. Updated recovery procedures.',
        },
      ],
    },
    {
      id: 'doc-004',
      name: 'Configuration Management Plan',
      expirationDate: '2025-06-30',
      lastReviewed: '2024-06-30',
      validationNotes: 'Current and valid',
      reviewHistory: [
        {
          date: '2024-06-30',
          notes: 'Updated to include new system components.',
        },
      ],
    },
  ],
};

export default mockAssessmentData;

================
File: mocks/atoTrackerMockData.js
================
import { processSteps } from '../../pages/system/atoProcessData';

// Initialize mock data from process steps
const initializeProcessData = () => {
  return {
    phases: processSteps.map(phase => ({
      ...phase,
      progress: 0,
      sections: phase.sections.map(section => ({
        ...section,
        tasks: section.tasks.map(task => ({
          description: task,
          completed: false
        }))
      }))
    }))
  };
};

// Mock data store
let mockProcessData = {};

// Helper to get or initialize process data for a system
const getSystemProcessData = (systemId) => {
  if (!mockProcessData[systemId]) {
    mockProcessData[systemId] = initializeProcessData();
  }
  return mockProcessData[systemId];
};

// Helper to calculate phase progress
const calculatePhaseProgress = (phase) => {
  let totalTasks = 0;
  let completedTasks = 0;

  phase.sections.forEach(section => {
    section.tasks.forEach(task => {
      totalTasks++;
      if (task.completed) {
        completedTasks++;
      }
    });
  });

  return Math.round((completedTasks / totalTasks) * 100);
};

// Helper to update phase progress
const updatePhaseProgress = (phase) => {
  return {
    ...phase,
    progress: calculatePhaseProgress(phase)
  };
};

export const atoTrackerMockData = {
  getProcessData: (systemId) => {
    return getSystemProcessData(systemId);
  },

  updateTaskStatus: (systemId, phaseId, sectionTitle, taskIndex, completed) => {
    const data = getSystemProcessData(systemId);
    
    // Find and update the task
    const phase = data.phases.find(p => p.id === phaseId);
    if (phase) {
      const section = phase.sections.find(s => s.title === sectionTitle);
      if (section && section.tasks[taskIndex]) {
        section.tasks[taskIndex].completed = completed;
        
        // Update phase progress
        const updatedPhase = updatePhaseProgress(phase);
        data.phases = data.phases.map(p => 
          p.id === phaseId ? updatedPhase : p
        );
      }
    }

    return data;
  },

  getPhaseProgress: (systemId, phaseId) => {
    const data = getSystemProcessData(systemId);
    const phase = data.phases.find(p => p.id === phaseId);
    return {
      value: phase ? phase.progress : 0
    };
  },

  // Reset mock data (useful for testing)
  resetMockData: () => {
    mockProcessData = {};
  }
};

================
File: mocks/authorizationMockData.js
================
// Initial mock data
const mockAuthData = {
  'client-1': {
    'sys-001': {
      riskAssessment: {
        risks: [
          {
            id: 'RISK-001',
            description: 'Insufficient access controls',
            likelihood: 'high',
            impact: 'high',
            status: 'open',
          },
        ],
        nonCompliantControls: [
          {
            controlId: 'AC-2',
            title: 'Account Management',
            status: 'non-compliant',
            findings: 'Missing automated account management procedures',
          },
        ],
      },
      package: {
        completed: ['System Security Plan', 'Risk Assessment Report'],
        pending: ['Privacy Impact Assessment', 'Contingency Plan'],
        executiveSummary: 'System implements moderate security controls with some gaps identified.',
        status: 'in-progress',
        validationStatus: 'pending',
        completionPercentage: 65,
      },
      decision: {
        result: 'pending',
        official: '',
        date: '',
        expirationDate: '',
        justification: '',
        conditions: [],
        boundary: 'System includes all components within the development network segment.',
      },
    },
  },
};

// Helper function to get client system data
const getClientSystemData = (clientId, systemId) => {
  const data = mockAuthData[clientId]?.[systemId];
  if (!data) {
    throw new Error('Authorization data not found');
  }
  return { ...data }; // Return a copy to prevent direct modification
};

const authorizationMockData = {
  getAuthorizationData: async (clientId, systemId) => {
    return getClientSystemData(clientId, systemId);
  },

  updateRiskAssessment: async (clientId, systemId, riskData) => {
    const currentData = getClientSystemData(clientId, systemId);
    mockAuthData[clientId][systemId].riskAssessment = {
      ...currentData.riskAssessment,
      ...riskData,
    };
    return { ...mockAuthData[clientId][systemId] };
  },

  createPOAMItem: async (clientId, systemId, poamItem) => {
    const newRisk = {
      id: `RISK-${Date.now()}`,
      ...poamItem,
      status: 'open',
    };
    mockAuthData[clientId][systemId].riskAssessment.risks.push(newRisk);
    return { ...mockAuthData[clientId][systemId] };
  },

  updateAuthorizationPackage: async (clientId, systemId, packageData) => {
    const currentData = getClientSystemData(clientId, systemId);
    mockAuthData[clientId][systemId].package = {
      ...currentData.package,
      ...packageData,
    };
    return { ...mockAuthData[clientId][systemId] };
  },

  validateAuthorizationPackage: async (clientId, systemId) => {
    getClientSystemData(clientId, systemId); // Verify system exists
    mockAuthData[clientId][systemId].package.validationStatus = 'validated';
    mockAuthData[clientId][systemId].package.completionPercentage = 100;
    return { ...mockAuthData[clientId][systemId] };
  },

  updateAuthorizationDecision: async (clientId, systemId, decisionData) => {
    const currentData = getClientSystemData(clientId, systemId);
    mockAuthData[clientId][systemId].decision = {
      ...currentData.decision,
      ...decisionData,
    };
    return { ...mockAuthData[clientId][systemId] };
  },
};

export { mockAuthData };
export default authorizationMockData;

================
File: mocks/data/assessment/advanced_questions.json
================
{
  "advancesQuestions": [
    {
      "id": "AC-1-Q1",
      "controlId": "AC-1",
      "text": "Has the organization developed and documented access control policies and procedures?",
      "impact": "Access control policies are fundamental to system security",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing access control policies and procedures",
        "description": "Organization lacks documented access control policies and procedures",
        "severity": "high",
        "recommendation": "Develop and document comprehensive access control policies and procedures",
        "category": "Access Control",
        "nistControl": "AC-1"
      }
    },
    {
      "id": "AC-2-Q1",
      "controlId": "AC-2",
      "text": "Does the organization implement automated account management processes?",
      "impact": "Automated account management ensures consistent access control",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Lack of automated account management",
        "description": "Account management processes are not automated",
        "severity": "high",
        "recommendation": "Implement automated account management system",
        "category": "Access Control",
        "nistControl": "AC-2"
      }
    },
    {
      "id": "AC-2-Q2",
      "controlId": "AC-2",
      "text": "Are account creation, modification, and termination processes documented and followed?",
      "impact": "Proper account lifecycle management prevents unauthorized access",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Inadequate account lifecycle management",
        "description": "Account management processes are not properly documented or followed",
        "severity": "high",
        "recommendation": "Document and implement account lifecycle management procedures",
        "category": "Access Control",
        "nistControl": "AC-2"
      }
    },
    {
      "id": "AC-3-Q1",
      "controlId": "AC-3",
      "text": "Is role-based access control (RBAC) implemented across all systems?",
      "impact": "RBAC ensures proper access enforcement",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing role-based access control",
        "description": "Systems do not implement role-based access control",
        "severity": "high",
        "recommendation": "Implement RBAC across all systems",
        "category": "Access Control",
        "nistControl": "AC-3"
      }
    },
    {
      "id": "AC-4-Q1",
      "controlId": "AC-4",
      "text": "Are information flow controls implemented between system components?",
      "impact": "Information flow control prevents unauthorized data transfer",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing information flow controls",
        "description": "System lacks proper information flow controls between components",
        "severity": "high",
        "recommendation": "Implement information flow controls between system components",
        "category": "Access Control",
        "nistControl": "AC-4"
      }
    },
    {
      "id": "AC-5-Q1",
      "controlId": "AC-5",
      "text": "Is separation of duties enforced through assigned access authorizations?",
      "impact": "Separation of duties prevents abuse of privileges",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Lack of separation of duties",
        "description": "System does not enforce separation of duties through access controls",
        "severity": "high",
        "recommendation": "Implement separation of duties in access authorizations",
        "category": "Access Control",
        "nistControl": "AC-5"
      }
    },
    {
      "id": "AC-6-Q1",
      "controlId": "AC-6",
      "text": "Is the principle of least privilege enforced for all user types?",
      "impact": "Least privilege minimizes potential damage from accidents or malicious acts",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Insufficient least privilege implementation",
        "description": "System does not properly enforce principle of least privilege",
        "severity": "high",
        "recommendation": "Implement least privilege access controls",
        "category": "Access Control",
        "nistControl": "AC-6"
      }
    },
    {
      "id": "AU-2-Q1",
      "controlId": "AU-2",
      "text": "Are audit events defined and logged across all systems?",
      "impact": "Audit logging is essential for security monitoring",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Insufficient audit logging",
        "description": "Systems do not have proper audit event logging configured",
        "severity": "high",
        "recommendation": "Define and implement comprehensive audit logging",
        "category": "Audit and Accountability",
        "nistControl": "AU-2"
      }
    },
    {
      "id": "AU-3-Q1",
      "controlId": "AU-3",
      "text": "Do audit records contain sufficient information for forensic analysis?",
      "impact": "Detailed audit records enable incident investigation",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Insufficient audit record content",
        "description": "Audit records lack necessary detail for forensic analysis",
        "severity": "high",
        "recommendation": "Configure audit logging to capture all required information",
        "category": "Audit and Accountability",
        "nistControl": "AU-3"
      }
    },
    {
      "id": "AU-6-Q1",
      "controlId": "AU-6",
      "text": "Is there a process for regular audit log review and analysis?",
      "impact": "Regular log review helps detect security incidents",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Inadequate audit log review",
        "description": "Organization lacks regular audit log review process",
        "severity": "high",
        "recommendation": "Implement regular audit log review procedures",
        "category": "Audit and Accountability",
        "nistControl": "AU-6"
      }
    },
    {
      "id": "AU-8-Q1",
      "controlId": "AU-8",
      "text": "Are system clocks synchronized across all systems for accurate timestamps?",
      "impact": "Time synchronization ensures accurate event correlation",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Lack of time synchronization",
        "description": "System clocks not properly synchronized",
        "severity": "medium",
        "recommendation": "Implement NTP or similar time synchronization",
        "category": "Audit and Accountability",
        "nistControl": "AU-8"
      }
    },
    {
      "id": "AU-9-Q1",
      "controlId": "AU-9",
      "text": "Are audit records protected from unauthorized access and modification?",
      "impact": "Protected audit records maintain integrity of security monitoring",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Unprotected audit records",
        "description": "Audit records not adequately protected from tampering",
        "severity": "high",
        "recommendation": "Implement audit record protection mechanisms",
        "category": "Audit and Accountability",
        "nistControl": "AU-9"
      }
    },
    {
      "id": "CM-2-Q1",
      "controlId": "CM-2",
      "text": "Is there a documented baseline configuration for all systems?",
      "impact": "Baseline configurations ensure consistent security",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Missing baseline configurations",
        "description": "Systems lack documented baseline configurations",
        "severity": "high",
        "recommendation": "Develop and maintain baseline configurations for all systems",
        "category": "Configuration Management",
        "nistControl": "CM-2"
      }
    },
    {
      "id": "CM-3-Q1",
      "controlId": "CM-3",
      "text": "Is there a change management process for system modifications?",
      "impact": "Change management prevents unauthorized changes",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Inadequate change management",
        "description": "Organization lacks proper change management process",
        "severity": "high",
        "recommendation": "Implement formal change management procedures",
        "category": "Configuration Management",
        "nistControl": "CM-3"
      }
    },
    {
      "id": "CM-6-Q1",
      "controlId": "CM-6",
      "text": "Are configuration settings monitored and controlled?",
      "impact": "Configuration control maintains security posture",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Insufficient configuration control",
        "description": "Configuration settings not properly monitored or controlled",
        "severity": "high",
        "recommendation": "Implement configuration monitoring and control",
        "category": "Configuration Management",
        "nistControl": "CM-6"
      }
    },
    {
      "id": "CM-7-Q1",
      "controlId": "CM-7",
      "text": "Is the principle of least functionality enforced through application whitelisting?",
      "impact": "Least functionality reduces attack surface",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Missing application whitelisting",
        "description": "Systems do not enforce least functionality through whitelisting",
        "severity": "high",
        "recommendation": "Implement application whitelisting",
        "category": "Configuration Management",
        "nistControl": "CM-7"
      }
    },
    {
      "id": "IA-2-Q1",
      "controlId": "IA-2",
      "text": "Is multi-factor authentication required for all privileged accounts?",
      "impact": "MFA protects privileged access from compromise",
      "category": "Identification and Authentication",
      "findingTemplate": {
        "title": "Missing MFA for privileged accounts",
        "description": "Privileged accounts not protected by multi-factor authentication",
        "severity": "critical",
        "recommendation": "Implement MFA for all privileged account access",
        "category": "Identification and Authentication",
        "nistControl": "IA-2"
      }
    },
    {
      "id": "IA-4-Q1",
      "controlId": "IA-4",
      "text": "Are unique identifiers assigned to all system users?",
      "impact": "Unique identifiers ensure accountability",
      "category": "Identification and Authentication",
      "findingTemplate": {
        "title": "Non-unique user identifiers",
        "description": "System users not assigned unique identifiers",
        "severity": "high",
        "recommendation": "Implement unique identifier assignment process",
        "category": "Identification and Authentication",
        "nistControl": "IA-4"
      }
    },
    {
      "id": "IA-5-Q1",
      "controlId": "IA-5",
      "text": "Are password complexity and lifetime restrictions enforced?",
      "impact": "Strong passwords reduce risk of compromise",
      "category": "Identification and Authentication",
      "findingTemplate": {
        "title": "Weak password requirements",
        "description": "Password policies do not enforce adequate complexity or rotation",
        "severity": "high",
        "recommendation": "Implement strong password policies",
        "category": "Identification and Authentication",
        "nistControl": "IA-5"
      }
    },
    {
      "id": "IR-4-Q1",
      "controlId": "IR-4",
      "text": "Is there an incident handling capability in place?",
      "impact": "Incident handling ensures proper response to security events",
      "category": "Incident Response",
      "findingTemplate": {
        "title": "Missing incident handling capability",
        "description": "Organization lacks proper incident handling procedures",
        "severity": "high",
        "recommendation": "Establish incident handling capability",
        "category": "Incident Response",
        "nistControl": "IR-4"
      }
    },
    {
      "id": "IR-5-Q1",
      "controlId": "IR-5",
      "text": "Are security incidents tracked and documented?",
      "impact": "Incident tracking enables trend analysis and improvement",
      "category": "Incident Response",
      "findingTemplate": {
        "title": "Inadequate incident tracking",
        "description": "Security incidents not properly tracked and documented",
        "severity": "high",
        "recommendation": "Implement incident tracking system",
        "category": "Incident Response",
        "nistControl": "IR-5"
      }
    },
    {
      "id": "IR-6-Q1",
      "controlId": "IR-6",
      "text": "Is there a process for incident reporting?",
      "impact": "Incident reporting ensures timely response",
      "category": "Incident Response",
      "findingTemplate": {
        "title": "Missing incident reporting process",
        "description": "Organization lacks formal incident reporting procedures",
        "severity": "high",
        "recommendation": "Establish incident reporting procedures",
        "category": "Incident Response",
        "nistControl": "IR-6"
      }
    },
    {
      "id": "SC-7-Q1",
      "controlId": "SC-7",
      "text": "Are boundary protection mechanisms implemented?",
      "impact": "Boundary protection prevents unauthorized network access",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Insufficient boundary protection",
        "description": "System boundaries lack proper protection mechanisms",
        "severity": "high",
        "recommendation": "Implement boundary protection controls",
        "category": "System and Communications Protection",
        "nistControl": "SC-7"
      }
    },
    {
      "id": "SC-8-Q1",
      "controlId": "SC-8",
      "text": "Is transmission confidentiality and integrity protected?",
      "impact": "Protected transmission prevents data compromise",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Unprotected data transmission",
        "description": "Data transmission lacks confidentiality and integrity protection",
        "severity": "high",
        "recommendation": "Implement transmission protection mechanisms",
        "category": "System and Communications Protection",
        "nistControl": "SC-8"
      }
    },
    {
      "id": "SC-12-Q1",
      "controlId": "SC-12",
      "text": "Are cryptographic keys properly managed throughout their lifecycle?",
      "impact": "Key management ensures cryptographic security",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Inadequate cryptographic key management",
        "description": "Cryptographic keys not properly managed",
        "severity": "high",
        "recommendation": "Implement cryptographic key management procedures",
        "category": "System and Communications Protection",
        "nistControl": "SC-12"
      }
    },
    {
      "id": "SC-13-Q1",
      "controlId": "SC-13",
      "text": "Are FIPS-validated or NSA-approved cryptography used?",
      "impact": "Approved cryptography ensures adequate protection",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Non-approved cryptography",
        "description": "System uses non-approved cryptographic algorithms",
        "severity": "high",
        "recommendation": "Implement FIPS-validated cryptography",
        "category": "System and Communications Protection",
        "nistControl": "SC-13"
      }
    },
    {
      "id": "SI-2-Q1",
      "controlId": "SI-2",
      "text": "Are system flaws identified and corrected?",
      "impact": "Flaw remediation prevents exploitation",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Inadequate flaw remediation",
        "description": "System flaws not properly identified and corrected",
        "severity": "high",
        "recommendation": "Implement flaw remediation process",
        "category": "System and Information Integrity",
        "nistControl": "SI-2"
      }
    },
    {
      "id": "SI-3-Q1",
      "controlId": "SI-3",
      "text": "Is malicious code protection implemented and updated?",
      "impact": "Malware protection prevents system compromise",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Insufficient malware protection",
        "description": "Systems lack adequate malicious code protection",
        "severity": "high",
        "recommendation": "Implement comprehensive malware protection",
        "category": "System and Information Integrity",
        "nistControl": "SI-3"
      }
    },
    {
      "id": "SI-4-Q1",
      "controlId": "SI-4",
      "text": "Is system monitoring capability implemented?",
      "impact": "Monitoring detects potential security violations",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Insufficient system monitoring",
        "description": "System lacks proper monitoring capability",
        "severity": "high",
        "recommendation": "Implement comprehensive system monitoring",
        "category": "System and Information Integrity",
        "nistControl": "SI-4"
      }
    },
    {
      "id": "SI-5-Q1",
      "controlId": "SI-5",
      "text": "Are security alerts and advisories monitored and acted upon?",
      "impact": "Security alerts enable timely response to threats",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Inadequate security alert monitoring",
        "description": "Organization does not properly monitor or respond to security alerts",
        "severity": "high",
        "recommendation": "Implement security alert monitoring and response procedures",
        "category": "System and Information Integrity",
        "nistControl": "SI-5"
      }
    }
  ]
}

================
File: mocks/data/assessment/assessments.json
================
{
  "assessmentHistory": [
    {
      "id": "asmt-001",
      "date": "2025-02-01T08:00:00Z",
      "type": "basic",
      "name": "Basic Security Assessment Feb 2025",
      "score": 75,
      "status": "completed",
      "clientId": 1,
      "systemId": "sys-001",
      "answers": [
        {
          "questionId": 1,
          "questionType": "basic",
          "answer": "no",
          "notes": "Antivirus software outdated on 30% of systems"
        },
        {
          "questionId": 2,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Firewalls properly configured"
        },
        {
          "questionId": 3,
          "questionType": "basic",
          "answer": "no",
          "notes": "MFA not implemented on development systems"
        },
        {
          "questionId": 4,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Password policies enforced through AD"
        },
        {
          "questionId": 5,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Monthly training sessions conducted"
        },
        {
          "questionId": 6,
          "questionType": "basic",
          "answer": "no",
          "notes": "Backup testing not performed regularly"
        },
        {
          "questionId": 7,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Encryption implemented for all sensitive data"
        },
        {
          "questionId": 8,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Regular patch management in place"
        }
      ],
      "generatedFindings": [
        {
          "id": "f-001",
          "sourceQuestionId": 1,
          "questionType": "basic",
          "title": "Missing or outdated antivirus protection",
          "description": "Systems lack proper antivirus protection or updates are not maintained",
          "severity": "high",
          "category": "System Security",
          "recommendation": "Install and configure antivirus software on all systems with automatic updates",
          "status": "open",
          "createdDate": "2025-02-01T08:00:00Z"
        },
        {
          "id": "f-002",
          "sourceQuestionId": 6,
          "questionType": "basic",
          "title": "Insufficient backup procedures",
          "description": "Backup processes are not adequate or tested",
          "severity": "high",
          "category": "Data Protection",
          "recommendation": "Implement comprehensive backup strategy with regular testing",
          "status": "in_progress",
          "createdDate": "2025-02-01T08:00:00Z"
        }
      ]
    },
    {
      "id": "asmt-002",
      "date": "2025-02-15T10:00:00Z",
      "type": "advanced",
      "name": "NIST 800-53 Assessment Feb 2025",
      "score": 82,
      "status": "completed",
      "clientId": 1,
      "systemId": "sys-001",
      "answers": [
        {
          "questionId": "AU-2-Q1",
          "questionType": "advanced",
          "answer": "no",
          "notes": "Audit logging not configured on all systems"
        },
        {
          "questionId": "CM-2-Q1",
          "questionType": "advanced",
          "answer": "no",
          "notes": "Baseline configurations not documented"
        },
        {
          "questionId": "SI-4-Q1",
          "questionType": "advanced",
          "answer": "partial",
          "notes": "Monitoring implemented but not comprehensive"
        },
        {
          "questionId": "AC-2-Q1",
          "questionType": "advanced",
          "answer": "yes",
          "notes": "Automated account management implemented"
        },
        {
          "questionId": "SC-7-Q1",
          "questionType": "advanced",
          "answer": "yes",
          "notes": "Boundary protection mechanisms in place"
        }
      ],
      "generatedFindings": [
        {
          "id": "f-003",
          "sourceQuestionId": "AU-2-Q1",
          "questionType": "advanced",
          "title": "Inadequate audit logging",
          "description": "Systems do not have proper audit event logging configured",
          "severity": "high",
          "category": "Audit and Accountability",
          "recommendation": "Define and implement comprehensive audit logging",
          "status": "completed",
          "createdDate": "2025-02-15T10:00:00Z",
          "nistControl": "AU-2"
        },
        {
          "id": "f-004",
          "sourceQuestionId": "CM-2-Q1",
          "questionType": "advanced",
          "title": "Missing baseline configurations",
          "description": "Systems lack documented baseline configurations",
          "severity": "high",
          "category": "Configuration Management",
          "recommendation": "Develop and maintain baseline configurations for all systems",
          "status": "open",
          "createdDate": "2025-02-15T10:00:00Z",
          "nistControl": "CM-2"
        },
        {
          "id": "f-005",
          "sourceQuestionId": "SI-4-Q1",
          "questionType": "advanced",
          "title": "Insufficient system monitoring",
          "description": "System lacks proper monitoring capability",
          "severity": "high",
          "category": "System and Information Integrity",
          "recommendation": "Implement comprehensive system monitoring",
          "status": "in_progress",
          "createdDate": "2025-02-15T10:00:00Z",
          "nistControl": "SI-4"
        }
      ]
    }
  ]
}

================
File: mocks/data/assessment/authorization.json
================
{
  "authorizationPackages": [
    {
      "id": 1,
      "systemId": "sys-001",
      "clientId": 1,
      "completed": [
        { "id": 1, "name": "System Security Plan" },
        { "id": 2, "name": "Risk Assessment Report" }
      ],
      "pending": [
        { "id": 1, "name": "Privacy Impact Assessment" },
        { "id": 2, "name": "Contingency Plan" }
      ],
      "executiveSummary": "System implements moderate security controls with some gaps identified.",
      "status": "in-progress",
      "validationStatus": "pending",
      "completionPercentage": 65,
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "authorizationDecisions": [
    {
      "id": 1,
      "systemId": "sys-001",
      "clientId": 1,
      "result": "pending",
      "official": "",
      "date": "",
      "expirationDate": "",
      "justification": "",
      "conditions": [
        { "id": 1, "description": "Implement automated account management" },
        { "id": 2, "description": "Complete security assessment" }
      ],
      "boundary": "System includes all components within the development network segment.",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "authorizationRisks": [
    {
      "id": "RISK-001",
      "systemId": "sys-001",
      "clientId": 1,
      "description": "Insufficient access controls",
      "likelihood": "high",
      "impact": "high",
      "status": "open",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "nonCompliantControls": [
    {
      "id": 1,
      "systemId": "sys-001",
      "clientId": 1,
      "controlId": "AC-2",
      "title": "Account Management",
      "status": "non-compliant",
      "findings": "Missing automated account management procedures",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ]
}

================
File: mocks/data/assessment/basic_questions.json
================
{
  "basicQuestions": [
    {
      "id": 1,
      "text": "Is antivirus software installed and updated on all systems?",
      "impact": "Antivirus helps protect against malware and cyber threats",
      "category": "System Security",
      "findingTemplate": {
        "title": "Missing or outdated antivirus protection",
        "description": "Systems lack proper antivirus protection or updates are not maintained",
        "severity": "high",
        "recommendation": "Install and configure antivirus software on all systems with automatic updates",
        "category": "System Security"
      }
    },
    {
      "id": 2,
      "text": "Are firewalls configured and maintained on all network boundaries?",
      "impact": "Firewalls help prevent unauthorized network access",
      "category": "Network Security",
      "findingTemplate": {
        "title": "Inadequate firewall protection",
        "description": "Network boundaries lack proper firewall configuration",
        "severity": "high",
        "recommendation": "Deploy and configure firewalls at all network boundaries",
        "category": "Network Security"
      }
    },
    {
      "id": 3,
      "text": "Is multi-factor authentication (MFA) enabled for all critical systems?",
      "impact": "MFA significantly reduces the risk of unauthorized access",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing Multi-Factor Authentication",
        "description": "Critical systems lack MFA protection",
        "severity": "high",
        "recommendation": "Implement MFA for all critical system access",
        "category": "Access Control"
      }
    },
    {
      "id": 4,
      "text": "Are password policies enforced across all systems?",
      "impact": "Strong password policies are essential for access security",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Insufficient password policies",
        "description": "Password policies do not meet security requirements",
        "severity": "high",
        "recommendation": "Implement and enforce strong password policies",
        "category": "Access Control"
      }
    },
    {
      "id": 5,
      "text": "Is security awareness training provided regularly?",
      "impact": "Training helps prevent social engineering attacks",
      "category": "Security Awareness",
      "findingTemplate": {
        "title": "Inadequate security awareness training",
        "description": "Security awareness training is not regularly conducted",
        "severity": "medium",
        "recommendation": "Implement regular security awareness training program",
        "category": "Security Awareness"
      }
    },
    {
      "id": 6,
      "text": "Are regular backups performed and tested?",
      "impact": "Backups are critical for business continuity",
      "category": "Data Protection",
      "findingTemplate": {
        "title": "Insufficient backup procedures",
        "description": "Backup processes are not adequate or tested",
        "severity": "high",
        "recommendation": "Implement comprehensive backup strategy with regular testing",
        "category": "Data Protection"
      }
    },
    {
      "id": 7,
      "text": "Is sensitive data encrypted at rest and in transit?",
      "impact": "Encryption protects data from unauthorized access",
      "category": "Data Protection",
      "findingTemplate": {
        "title": "Inadequate data encryption",
        "description": "Sensitive data is not properly encrypted",
        "severity": "high",
        "recommendation": "Implement encryption for data at rest and in transit",
        "category": "Data Protection"
      }
    },
    {
      "id": 8,
      "text": "Is patch management performed regularly?",
      "impact": "Regular patching prevents exploitation of known vulnerabilities",
      "category": "System Security",
      "findingTemplate": {
        "title": "Inadequate patch management",
        "description": "Systems are not patched regularly",
        "severity": "high",
        "recommendation": "Implement regular patch management process",
        "category": "System Security"
      }
    }
  ]
}

================
File: mocks/data/assessment/controls.json
================
{
  "controls": [
    {
      "id": "AC-1",
      "title": "Access Control Policy and Procedures",
      "status": "Compliant",
      "evidence": "Access Control Policy v2.1 implemented and reviewed",
      "notes": "Annual review completed",
      "lastUpdated": "2025-02-10T09:00:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-10T09:00:00Z",
      "updatedAt": "2025-02-10T09:00:00Z"
    },
    {
      "id": "AC-2",
      "title": "Account Management",
      "status": "Non-Compliant",
      "evidence": "Automated account review process not implemented",
      "notes": "Implementation in progress",
      "lastUpdated": "2025-02-11T15:30:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-11T15:30:00Z",
      "updatedAt": "2025-02-11T15:30:00Z"
    },
    {
      "id": "AC-3",
      "title": "Access Enforcement",
      "status": "Compliant",
      "evidence": "Role-based access control implemented",
      "notes": "Verified during testing",
      "lastUpdated": "2025-02-12T11:20:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-12T11:20:00Z",
      "updatedAt": "2025-02-12T11:20:00Z"
    },
    {
      "id": "AC-4",
      "title": "Information Flow Enforcement",
      "status": "Not-Applicable",
      "evidence": "System does not process classified information",
      "notes": "Approved deviation",
      "lastUpdated": "2025-02-13T14:15:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-13T14:15:00Z",
      "updatedAt": "2025-02-13T14:15:00Z"
    }
  ]
}

================
File: mocks/data/assessment/documents.json
================
{
  "assessmentDocuments": [
    {
      "id": "doc-001",
      "name": "System Security Plan",
      "expirationDate": "2026-02-20",
      "lastReviewed": "2025-02-15",
      "validationNotes": "Annual review completed. Updates required for new controls.",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2025-02-15",
          "notes": "Annual review completed. Updates required for new controls."
        },
        {
          "id": 2,
          "date": "2024-02-15",
          "notes": "Initial review completed."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-02-15T00:00:00Z",
      "updatedAt": "2025-02-15T00:00:00Z"
    },
    {
      "id": "doc-002",
      "name": "Incident Response Plan",
      "expirationDate": "2025-03-15",
      "lastReviewed": "2024-03-15",
      "validationNotes": "Review needed before expiration",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2024-03-15",
          "notes": "Annual review completed. No major changes required."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-03-15T00:00:00Z",
      "updatedAt": "2024-03-15T00:00:00Z"
    },
    {
      "id": "doc-003",
      "name": "Contingency Plan",
      "expirationDate": "2025-01-10",
      "lastReviewed": "2024-01-10",
      "validationNotes": "Document expired. Immediate review required.",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2024-01-10",
          "notes": "Annual review completed. Updated recovery procedures."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-01-10T00:00:00Z",
      "updatedAt": "2024-01-10T00:00:00Z"
    },
    {
      "id": "doc-004",
      "name": "Configuration Management Plan",
      "expirationDate": "2025-06-30",
      "lastReviewed": "2024-06-30",
      "validationNotes": "Current and valid",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2024-06-30",
          "notes": "Updated to include new system components."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-06-30T00:00:00Z",
      "updatedAt": "2024-06-30T00:00:00Z"
    }
  ]
}

================
File: mocks/data/assessment/plans.json
================
{
  "assessmentPlans": [
    {
      "id": "ap-001",
      "assessmentTitle": "Annual Security Assessment 2025",
      "assessmentType": "Annual Assessment",
      "startDate": "2025-01-01",
      "endDate": "2025-03-31",
      "assessmentTeam": "Security Team A\nExternal Auditor: SecureAudit Inc.",
      "objectives": "Evaluate system security controls\nValidate compliance with security requirements\nIdentify potential vulnerabilities",
      "methodology": "NIST SP 800-53A Rev 5\nAutomated scanning\nManual testing\nDocument review",
      "scope": "All production systems\nNetwork infrastructure\nAccess controls\nSecurity policies",
      "requirements": "NIST 800-53 Low baseline\nOrganizational security policies\nRegulatory requirements",
      "status": "in-progress",
      "clientId": 1,
      "systemId": "sys-001",
      "createdAt": "2025-01-01T00:00:00Z",
      "updatedAt": "2025-02-19T10:00:00Z"
    }
  ]
}

================
File: mocks/data/assessment/scan_results.json
================
{
  "scanResults": [
    {
      "id": "scan-001",
      "type": "STIG Scan",
      "date": "2025-02-15T10:00:00Z",
      "findings": {
        "high": 2,
        "medium": 5,
        "low": 8
      },
      "status": "Completed",
      "downloadUrl": "#",
      "detailsUrl": "#",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-15T10:00:00Z",
      "updatedAt": "2025-02-15T10:00:00Z"
    },
    {
      "id": "scan-002",
      "type": "SCAP Scan",
      "date": "2025-02-01T14:30:00Z",
      "findings": {
        "high": 1,
        "medium": 3,
        "low": 6
      },
      "status": "Completed",
      "downloadUrl": "#",
      "detailsUrl": "#",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-01T14:30:00Z",
      "updatedAt": "2025-02-01T14:30:00Z"
    }
  ]
}

================
File: mocks/data/auth/roles.json
================
{
  "roles": {
    "SENIOR_AO": {
      "name": "Senior Authorizing Official",
      "description": "Top-level authorization authority with full system access",
      "permissions": [
        "all"
      ],
      "level": 1
    },
    "SUBORDINATE_AO": {
      "name": "Subordinate Authorizing Official",
      "description": "Secondary authorization authority with approval capabilities",
      "permissions": [
        "view",
        "edit",
        "approve"
      ],
      "level": 2
    },
    "AODR": {
      "name": "Authorizing Official Designated Representative",
      "description": "Acts on behalf of authorizing officials for reviews and assessments",
      "permissions": [
        "view",
        "edit",
        "review"
      ],
      "level": 3
    },
    "SCA": {
      "name": "Security Control Assessor",
      "description": "Performs comprehensive security control assessments",
      "permissions": [
        "view",
        "assess",
        "review"
      ],
      "level": 3
    },
    "SCAR": {
      "name": "Security Control Assessor Representative",
      "description": "Assists in security control assessments and documentation",
      "permissions": [
        "view",
        "assess"
      ],
      "level": 4
    }
  },
  "permissions": [
    {
      "id": "all",
      "description": "Full system access with no restrictions"
    },
    {
      "id": "view",
      "description": "Read-only access to system information"
    },
    {
      "id": "edit",
      "description": "Ability to modify system information"
    },
    {
      "id": "approve",
      "description": "Authority to approve system changes and assessments"
    },
    {
      "id": "review",
      "description": "Ability to review and comment on system documentation"
    },
    {
      "id": "assess",
      "description": "Permission to perform security assessments"
    }
  ]
}

================
File: mocks/data/auth/users.json
================
{
  "users": [
    {
      "id": 1,
      "email": "senior.ao@example.com",
      "password": "password123",
      "firstName": "John",
      "lastName": "Smith",
      "role": "SENIOR_AO",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0123",
      "department": "Executive",
      "title": "Senior Authorizing Official",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "light",
        "language": "en"
      }
    },
    {
      "id": 2,
      "email": "sao@example.com",
      "password": "password123",
      "firstName": "Jane",
      "lastName": "Doe",
      "role": "SUBORDINATE_AO",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0124",
      "department": "Authorization",
      "title": "Subordinate Authorizing Official",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "light",
        "language": "en"
      }
    },
    {
      "id": 3,
      "email": "aodr@example.com",
      "password": "password123",
      "firstName": "Mike",
      "lastName": "Johnson",
      "role": "AODR",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0125",
      "department": "Authorization",
      "title": "AO Designated Representative",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "dark",
        "language": "en"
      }
    },
    {
      "id": 4,
      "email": "sca@example.com",
      "password": "password123",
      "firstName": "Sarah",
      "lastName": "Wilson",
      "role": "SCA",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0126",
      "department": "Security Assessment",
      "title": "Security Control Assessor",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "light",
        "language": "en"
      }
    },
    {
      "id": 5,
      "email": "scar@example.com",
      "password": "password123",
      "firstName": "David",
      "lastName": "Brown",
      "role": "SCAR",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0127",
      "department": "Security Assessment",
      "title": "Security Control Assessor Representative",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "dark",
        "language": "en"
      }
    }
  ],
  "statuses": [
    {
      "id": "active",
      "description": "User account is active and accessible"
    },
    {
      "id": "inactive",
      "description": "User account has been deactivated"
    },
    {
      "id": "suspended",
      "description": "User account has been temporarily suspended"
    },
    {
      "id": "pending_activation",
      "description": "User account awaiting activation"
    }
  ],
  "preferences": {
    "themes": [
      {
        "id": "light",
        "name": "Light Theme",
        "description": "Default light color scheme"
      },
      {
        "id": "dark",
        "name": "Dark Theme",
        "description": "Dark color scheme for low-light environments"
      }
    ],
    "languages": [
      {
        "id": "en",
        "name": "English",
        "code": "en-US"
      },
      {
        "id": "es",
        "name": "Spanish",
        "code": "es-ES"
      },
      {
        "id": "fr",
        "name": "French",
        "code": "fr-FR"
      }
    ],
    "notificationTypes": [
      {
        "id": "email",
        "name": "Email Notifications",
        "description": "Receive notifications via email"
      },
      {
        "id": "in-app",
        "name": "In-App Notifications",
        "description": "Receive notifications within the application"
      },
      {
        "id": "sms",
        "name": "SMS Notifications",
        "description": "Receive notifications via text message"
      }
    ]
  }
}

================
File: mocks/data/client_data/client_users.json
================
{
  "roles": [
    {
      "id": "PROGRAM_MANAGER",
      "name": "PROGRAM_MANAGER"
    },
    {
      "id": "ISSM",
      "name": "ISSM"
    },
    {
      "id": "ISSO",
      "name": "ISSO"
    },
    {
      "id": "ISSE",
      "name": "ISSE"
    },
    {
      "id": "SYSTEM_ADMIN",
      "name": "SYSTEM_ADMIN"
    }
  ],
  "rolePermissions": [
    {
      "id": "PROGRAM_MANAGER",
      "permissions": ["manage_users", "manage_systems", "view_audits", "manage_strategy"]
    },
    {
      "id": "ISSM",
      "permissions": ["manage_users", "manage_systems", "manage_audits", "manage_strategy"]
    },
    {
      "id": "ISSO",
      "permissions": ["view_users", "manage_systems", "manage_audits"]
    },
    {
      "id": "ISSE",
      "permissions": ["view_users", "view_systems", "view_audits"]
    },
    {
      "id": "SYSTEM_ADMIN",
      "permissions": ["all"]
    }
  ],
  "permissions": [
    {
      "id": "manage_users",
      "name": "manage_users"
    },
    {
      "id": "view_users",
      "name": "view_users"
    },
    {
      "id": "manage_systems",
      "name": "manage_systems"
    },
    {
      "id": "view_systems",
      "name": "view_systems"
    },
    {
      "id": "manage_audits",
      "name": "manage_audits"
    },
    {
      "id": "view_audits",
      "name": "view_audits"
    },
    {
      "id": "manage_strategy",
      "name": "manage_strategy"
    },
    {
      "id": "all",
      "name": "all"
    }
  ],
  "users": [
    {
      "id": 1,
      "username": "john.smith",
      "email": "john.smith@acme.com",
      "role": "PROGRAM_MANAGER",
      "clientId": 1,
      "firstName": "John",
      "lastName": "Smith",
      "title": "Program Manager",
      "department": "Security",
      "phone": "(555) 123-4567",
      "isActive": true,
      "lastActive": "2024-02-19T10:00:00Z",
      "permissions": ["manage_users", "manage_systems", "view_audits", "manage_strategy"]
    },
    {
      "id": 2,
      "username": "sarah.johnson",
      "email": "sarah.johnson@acme.com",
      "role": "ISSM",
      "clientId": 1,
      "firstName": "Sarah",
      "lastName": "Johnson",
      "title": "Information System Security Manager",
      "department": "Security",
      "phone": "(555) 234-5678",
      "isActive": true,
      "lastActive": "2024-02-19T09:00:00Z",
      "permissions": ["manage_users", "manage_systems", "manage_audits", "manage_strategy"]
    },
    {
      "id": 3,
      "username": "mike.wilson",
      "email": "mike.wilson@acme.com",
      "role": "ISSO",
      "clientId": 1,
      "firstName": "Mike",
      "lastName": "Wilson",
      "title": "Information System Security Officer",
      "department": "IT",
      "phone": "(555) 345-6789",
      "isActive": true,
      "lastActive": "2024-02-19T08:00:00Z",
      "permissions": ["view_users", "manage_systems", "manage_audits"]
    },
    {
      "id": 4,
      "username": "alice.brown",
      "email": "alice.brown@healthcareplus.com",
      "role": "PROGRAM_MANAGER",
      "clientId": 2,
      "firstName": "Alice",
      "lastName": "Brown",
      "title": "Security Program Manager",
      "department": "Security",
      "phone": "(555) 456-7890",
      "isActive": true,
      "lastActive": "2024-02-19T11:00:00Z",
      "permissions": ["manage_users", "manage_systems", "view_audits", "manage_strategy"]
    },
    {
      "id": 5,
      "username": "admin",
      "email": "admin@grc.com",
      "role": "SYSTEM_ADMIN",
      "clientId": null,
      "firstName": "System",
      "lastName": "Administrator",
      "title": "System Administrator",
      "department": "IT",
      "phone": "(555) 999-9999",
      "isActive": true,
      "lastActive": "2024-02-19T12:00:00Z",
      "permissions": ["all"]
    }
  ],
  "departments": [
    {
      "id": "Security",
      "name": "Security"
    },
    {
      "id": "IT",
      "name": "IT"
    },
    {
      "id": "Compliance",
      "name": "Compliance"
    },
    {
      "id": "Risk Management",
      "name": "Risk Management"
    },
    {
      "id": "Operations",
      "name": "Operations"
    },
    {
      "id": "Executive",
      "name": "Executive"
    }
  ],
  "titles": [
    {
      "id": "Program Manager",
      "name": "Program Manager"
    },
    {
      "id": "Information System Security Manager",
      "name": "Information System Security Manager"
    },
    {
      "id": "Information System Security Officer",
      "name": "Information System Security Officer"
    },
    {
      "id": "Security Engineer",
      "name": "Security Engineer"
    },
    {
      "id": "System Administrator",
      "name": "System Administrator"
    },
    {
      "id": "Security Analyst",
      "name": "Security Analyst"
    },
    {
      "id": "Compliance Officer",
      "name": "Compliance Officer"
    },
    {
      "id": "Risk Manager",
      "name": "Risk Manager"
    }
  ],
  "userStatus": [
    {
      "id": "active",
      "name": "active"
    },
    {
      "id": "inactive",
      "name": "inactive"
    },
    {
      "id": "suspended",
      "name": "suspended"
    },
    {
      "id": "pending",
      "name": "pending"
    }
  ]
}

================
File: mocks/data/client_data/clients.json
================
{
  "clients": [
    {
      "id": 1,
      "name": "Acme Corporation",
      "industry": "Technology",
      "email": "contact@acme.com",
      "phone": "(555) 123-4567",
      "primaryContact": "John Smith",
      "createdAt": "2024-01-01T10:00:00Z",
      "lastActivity": "2024-02-19T10:00:00Z",
      "complianceScore": 85,
      "status": "active",
      "address": {
        "street": "123 Tech Lane",
        "city": "San Francisco",
        "state": "CA",
        "zip": "94105",
        "country": "USA"
      },
      "size": "Enterprise",
      "employeeCount": 5000,
      "website": "www.acme.com"
    }
  ]
}

================
File: mocks/data/client_data/departments.json
================
{
  "departments": [
    {
      "id": 1,
      "clientId": 1,
      "name": "Information Technology",
      "head": "David Wilson",
      "headTitle": "CTO",
      "employeeCount": 150,
      "positions": [
        { "id": 1, "name": "Software Engineer" },
        { "id": 2, "name": "System Administrator" },
        { "id": 3, "name": "Security Analyst" }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    },
    {
      "id": 2,
      "clientId": 1,
      "name": "Security Operations",
      "head": "Alice Brown",
      "headTitle": "CISO",
      "employeeCount": 50,
      "positions": [
        { "id": 1, "name": "Security Engineer" },
        { "id": 2, "name": "Incident Responder" },
        { "id": 3, "name": "Security Analyst" }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    },
    {
      "id": 3,
      "clientId": 1,
      "name": "Risk & Compliance",
      "head": "Michael Chen",
      "headTitle": "Risk Director",
      "employeeCount": 35,
      "positions": [
        { "id": 1, "name": "Risk Analyst" },
        { "id": 2, "name": "Compliance Officer" },
        { "id": 3, "name": "Auditor" }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    },
    {
      "id": 4,
      "clientId": 1,
      "name": "Network Operations",
      "head": "Sarah Johnson",
      "headTitle": "Network Director",
      "employeeCount": 45,
      "positions": [
        { "id": 1, "name": "Network Engineer" },
        { "id": 2, "name": "Infrastructure Specialist" },
        { "id": 3, "name": "Cloud Architect" }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    }
  ]
}

================
File: mocks/data/client_data/documents.json
================
{
  "documents": [
    {
      "id": 1,
      "clientId": 1,
      "name": "Security Policy.pdf",
      "type": "PDF",
      "lastUpdated": "2024-02-19T10:00:00Z",
      "category": "Policies",
      "size": 2500000,
      "uploadedBy": "John Smith"
    },
    {
      "id": 2,
      "clientId": 1,
      "name": "Incident Response Plan.docx",
      "type": "DOCX",
      "lastUpdated": "2024-02-18T10:00:00Z",
      "category": "Procedures",
      "size": 1800000,
      "uploadedBy": "Alice Brown"
    },
    {
      "id": 3,
      "clientId": 1,
      "name": "Risk Assessment Report.pdf",
      "type": "PDF",
      "lastUpdated": "2024-02-19T09:00:00Z",
      "category": "Reports",
      "size": 3200000,
      "uploadedBy": "Michael Chen"
    },
    {
      "id": 4,
      "clientId": 1,
      "name": "Network Security Architecture.pptx",
      "type": "PPT",
      "lastUpdated": "2024-02-17T14:00:00Z",
      "category": "Documentation",
      "size": 4500000,
      "uploadedBy": "Sarah Johnson"
    },
    {
      "id": 5,
      "clientId": 1,
      "name": "Security Training Materials.zip",
      "type": "ZIP",
      "lastUpdated": "2024-02-16T11:00:00Z",
      "category": "Training",
      "size": 15000000,
      "uploadedBy": "David Wilson"
    }
  ]
}

================
File: mocks/data/client_data/key_personnel.json
================
{
  "keyPersonnel": [
    {
      "id": 1,
      "clientId": 1,
      "departmentId": null,
      "name": "John Smith",
      "role": "Primary Contact",
      "department": "Executive",
      "title": "CEO"
    },
    {
      "id": 2,
      "clientId": 1,
      "departmentId": 1,
      "name": "David Wilson",
      "role": "Technology Lead",
      "department": "Information Technology",
      "title": "CTO"
    },
    {
      "id": 3,
      "clientId": 1,
      "departmentId": 2,
      "name": "Alice Brown",
      "role": "Security Lead",
      "department": "Security Operations",
      "title": "CISO"
    },
    {
      "id": 4,
      "clientId": 1,
      "departmentId": 3,
      "name": "Michael Chen",
      "role": "Risk Lead",
      "department": "Risk & Compliance",
      "title": "Risk Director"
    },
    {
      "id": 5,
      "clientId": 1,
      "departmentId": 4,
      "name": "Sarah Johnson",
      "role": "Infrastructure Lead",
      "department": "Network Operations",
      "title": "Network Director"
    }
  ]
}

================
File: mocks/data/client_data/reference_data.json
================
{
  "industries": [
    { "id": 1, "name": "Technology" },
    { "id": 2, "name": "Healthcare" },
    { "id": 3, "name": "Financial Services" },
    { "id": 4, "name": "Manufacturing" },
    { "id": 5, "name": "Retail" },
    { "id": 6, "name": "Energy" },
    { "id": 7, "name": "Education" },
    { "id": 8, "name": "Government" },
    { "id": 9, "name": "Non-Profit" }
  ],
  "clientSizes": [
    { "id": 1, "name": "Small" },
    { "id": 2, "name": "Medium" },
    { "id": 3, "name": "Large" },
    { "id": 4, "name": "Enterprise" }
  ],
  "clientStatuses": [
    { "id": 1, "name": "active" },
    { "id": 2, "name": "inactive" },
    { "id": 3, "name": "suspended" },
    { "id": 4, "name": "pending" }
  ],
  "documentCategories": [
    { "id": 1, "name": "Policies" },
    { "id": 2, "name": "Procedures" },
    { "id": 3, "name": "Compliance" },
    { "id": 4, "name": "Reports" },
    { "id": 5, "name": "Training" },
    { "id": 6, "name": "Documentation" },
    { "id": 7, "name": "General" }
  ],
  "documentTypes": [
    { "id": 1, "name": "PDF" },
    { "id": 2, "name": "DOCX" },
    { "id": 3, "name": "XLSX" },
    { "id": 4, "name": "PPT" },
    { "id": 5, "name": "TXT" },
    { "id": 6, "name": "ZIP" }
  ]
}

================
File: mocks/data/incidents/enums.json
================
{
  "incidentTypes": [
    { "id": 1, "name": "security" },
    { "id": 2, "name": "system" },
    { "id": 3, "name": "network" },
    { "id": 4, "name": "application" },
    { "id": 5, "name": "hardware" },
    { "id": 6, "name": "software" },
    { "id": 7, "name": "data" },
    { "id": 8, "name": "user" },
    { "id": 9, "name": "other" }
  ],
  "incidentSeverities": [
    { "id": 1, "name": "critical" },
    { "id": 2, "name": "high" },
    { "id": 3, "name": "medium" },
    { "id": 4, "name": "low" }
  ],
  "incidentStatuses": [
    { "id": 1, "name": "active" },
    { "id": 2, "name": "investigating" },
    { "id": 3, "name": "mitigated" },
    { "id": 4, "name": "resolved" },
    { "id": 5, "name": "closed" }
  ],
  "incidentPriorities": [
    { "id": 1, "name": "critical" },
    { "id": 2, "name": "high" },
    { "id": 3, "name": "medium" },
    { "id": 4, "name": "low" }
  ],
  "actionTypes": [
    { "id": 1, "name": "detection" },
    { "id": 2, "name": "investigation" },
    { "id": 3, "name": "mitigation" },
    { "id": 4, "name": "resolution" },
    { "id": 5, "name": "communication" },
    { "id": 6, "name": "escalation" }
  ],
  "teams": [
    { "id": 1, "name": "Information Technology" },
    { "id": 2, "name": "Security Operations" },
    { "id": 3, "name": "Risk & Compliance" },
    { "id": 4, "name": "Network Operations" }
  ],
  "systemTypes": [
    { "id": 1, "name": "Web Server" },
    { "id": 2, "name": "Database Server" },
    { "id": 3, "name": "Authentication Server" },
    { "id": 4, "name": "Network Infrastructure" },
    { "id": 5, "name": "Storage System" },
    { "id": 6, "name": "Backup System" },
    { "id": 7, "name": "End User Systems" },
    { "id": 8, "name": "Security Systems" },
    { "id": 9, "name": "Cloud Services" }
  ]
}

================
File: mocks/data/incidents/incidents.json
================
{
  "incidents": [
    {
      "id": 1,
      "clientId": 1,
      "title": "Unauthorized Access Attempt",
      "type": "security",
      "severity": "high",
      "status": "active", 
      "priority": "high",
      "createdAt": "2024-02-19T08:00:00Z",
      "updatedAt": "2024-02-19T10:30:00Z",
      "resolvedAt": null,
      "assignedTo": "Security Operations",
      "description": "Multiple failed login attempts detected from suspicious IP addresses",
      "affectedSystems": ["Authentication Server", "User Database"],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-19T08:00:00Z",
          "description": "IDS detected multiple failed login attempts",
          "performedBy": "Security Operations"
        },
        {
          "id": 2,
          "type": "mitigation",
          "timestamp": "2024-02-19T08:15:00Z",
          "description": "IP addresses temporarily blocked",
          "performedBy": "Alice Brown"
        },
        {
          "id": 3,
          "type": "investigation",
          "timestamp": "2024-02-19T10:30:00Z",
          "description": "Analysis of login attempt patterns",
          "performedBy": "Security Operations"
        }
      ]
    },
    {
      "id": 2,
      "clientId": 1,
      "title": "Data Backup Failure",
      "type": "system",
      "severity": "medium",
      "status": "resolved",
      "priority": "medium",
      "createdAt": "2024-02-18T15:00:00Z",
      "updatedAt": "2024-02-18T17:45:00Z",
      "resolvedAt": "2024-02-18T17:45:00Z",
      "assignedTo": "Information Technology",
      "description": "Scheduled backup job failed due to storage capacity issues",
      "affectedSystems": ["Backup System", "Storage System"],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-18T15:00:00Z",
          "description": "Backup job failure alert received",
          "performedBy": "Information Technology"
        },
        {
          "id": 2,
          "type": "investigation",
          "timestamp": "2024-02-18T15:30:00Z",
          "description": "Storage capacity analysis performed",
          "performedBy": "David Wilson"
        },
        {
          "id": 3,
          "type": "resolution",
          "timestamp": "2024-02-18T17:45:00Z",
          "description": "Additional storage allocated and backup job rerun successfully",
          "performedBy": "Information Technology"
        }
      ]
    },
    {
      "id": 3,
      "clientId": 1,
      "title": "SSL Certificate Expiration",
      "type": "security",
      "severity": "medium",
      "status": "active",
      "priority": "high",
      "createdAt": "2024-02-19T09:00:00Z",
      "updatedAt": "2024-02-19T09:30:00Z",
      "resolvedAt": null,
      "assignedTo": "Security Operations",
      "description": "SSL certificate for main website approaching expiration",
      "affectedSystems": ["Web Server"],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-19T09:00:00Z",
          "description": "Certificate expiration alert received",
          "performedBy": "Security Operations"
        },
        {
          "id": 2,
          "type": "mitigation",
          "timestamp": "2024-02-19T09:30:00Z",
          "description": "Certificate renewal process initiated",
          "performedBy": "Alice Brown"
        }
      ]
    },
    {
      "id": 4,
      "clientId": 1,
      "title": "Network Performance Degradation",
      "type": "network",
      "severity": "high",
      "status": "investigating",
      "priority": "high",
      "createdAt": "2024-02-19T11:00:00Z",
      "updatedAt": "2024-02-19T11:45:00Z",
      "resolvedAt": null,
      "assignedTo": "Network Operations",
      "description": "Users reporting slow network performance and intermittent connectivity issues",
      "affectedSystems": ["Network Infrastructure", "Cloud Services"],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-19T11:00:00Z",
          "description": "Multiple user reports of slow network performance",
          "performedBy": "Information Technology"
        },
        {
          "id": 2,
          "type": "investigation",
          "timestamp": "2024-02-19T11:45:00Z",
          "description": "Network monitoring analysis initiated",
          "performedBy": "Sarah Johnson"
        }
      ]
    }
  ]
}

================
File: mocks/data/system_data/packages.json
================
{
  "authorizationPackages": [
    {
      "id": 1,
      "systemId": "sys-001",
      "clientId": 1,
      "completed": ["System Security Plan", "Risk Assessment Report"],
      "pending": ["Privacy Impact Assessment", "Contingency Plan"],
      "executiveSummary": "System implements moderate security controls with some gaps identified.",
      "status": "in-progress",
      "validationStatus": "pending",
      "completionPercentage": 65,
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "authorizationDecisions": [
    {
      "id": 1,
      "systemId": "sys-001",
      "clientId": 1,
      "result": "pending",
      "official": "",
      "date": "",
      "expirationDate": "",
      "justification": "",
      "conditions": [],
      "boundary": "System includes all components within the development network segment.",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ]
}

================
File: mocks/data/system_data/risks.json
================
{
  "authorizationRisks": [
    {
      "id": "RISK-001",
      "systemId": "sys-001",
      "clientId": 1,
      "description": "Insufficient access controls",
      "likelihood": "high",
      "impact": "high",
      "status": "open",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "nonCompliantControls": [
    {
      "id": 1,
      "systemId": "sys-001",
      "clientId": 1,
      "controlId": "AC-2",
      "title": "Account Management",
      "status": "non-compliant",
      "findings": "Missing automated account management procedures",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ]
}

================
File: mocks/data/system_data/systems.json
================
{
  "systems": [
    {
      "id": "sys-001",
      "clientId": 1,
      "name": "Core Banking System",
      "description": "Primary banking and transaction processing system",
      "type": "Major Application",
      "status": "active",
      "createdAt": "2024-01-15",
      "updatedAt": "2024-02-10"
    }
  ]
}

================
File: mocks/db.json
================
{
  "advancesQuestions": [
    {
      "id": "AC-1-Q1",
      "controlId": "AC-1",
      "text": "Has the organization developed and documented access control policies and procedures?",
      "impact": "Access control policies are fundamental to system security",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing access control policies and procedures",
        "description": "Organization lacks documented access control policies and procedures",
        "severity": "high",
        "recommendation": "Develop and document comprehensive access control policies and procedures",
        "category": "Access Control",
        "nistControl": "AC-1"
      }
    },
    {
      "id": "AC-2-Q1",
      "controlId": "AC-2",
      "text": "Does the organization implement automated account management processes?",
      "impact": "Automated account management ensures consistent access control",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Lack of automated account management",
        "description": "Account management processes are not automated",
        "severity": "high",
        "recommendation": "Implement automated account management system",
        "category": "Access Control",
        "nistControl": "AC-2"
      }
    },
    {
      "id": "AC-2-Q2",
      "controlId": "AC-2",
      "text": "Are account creation, modification, and termination processes documented and followed?",
      "impact": "Proper account lifecycle management prevents unauthorized access",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Inadequate account lifecycle management",
        "description": "Account management processes are not properly documented or followed",
        "severity": "high",
        "recommendation": "Document and implement account lifecycle management procedures",
        "category": "Access Control",
        "nistControl": "AC-2"
      }
    },
    {
      "id": "AC-3-Q1",
      "controlId": "AC-3",
      "text": "Is role-based access control (RBAC) implemented across all systems?",
      "impact": "RBAC ensures proper access enforcement",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing role-based access control",
        "description": "Systems do not implement role-based access control",
        "severity": "high",
        "recommendation": "Implement RBAC across all systems",
        "category": "Access Control",
        "nistControl": "AC-3"
      }
    },
    {
      "id": "AC-4-Q1",
      "controlId": "AC-4",
      "text": "Are information flow controls implemented between system components?",
      "impact": "Information flow control prevents unauthorized data transfer",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing information flow controls",
        "description": "System lacks proper information flow controls between components",
        "severity": "high",
        "recommendation": "Implement information flow controls between system components",
        "category": "Access Control",
        "nistControl": "AC-4"
      }
    },
    {
      "id": "AC-5-Q1",
      "controlId": "AC-5",
      "text": "Is separation of duties enforced through assigned access authorizations?",
      "impact": "Separation of duties prevents abuse of privileges",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Lack of separation of duties",
        "description": "System does not enforce separation of duties through access controls",
        "severity": "high",
        "recommendation": "Implement separation of duties in access authorizations",
        "category": "Access Control",
        "nistControl": "AC-5"
      }
    },
    {
      "id": "AC-6-Q1",
      "controlId": "AC-6",
      "text": "Is the principle of least privilege enforced for all user types?",
      "impact": "Least privilege minimizes potential damage from accidents or malicious acts",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Insufficient least privilege implementation",
        "description": "System does not properly enforce principle of least privilege",
        "severity": "high",
        "recommendation": "Implement least privilege access controls",
        "category": "Access Control",
        "nistControl": "AC-6"
      }
    },
    {
      "id": "AU-2-Q1",
      "controlId": "AU-2",
      "text": "Are audit events defined and logged across all systems?",
      "impact": "Audit logging is essential for security monitoring",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Insufficient audit logging",
        "description": "Systems do not have proper audit event logging configured",
        "severity": "high",
        "recommendation": "Define and implement comprehensive audit logging",
        "category": "Audit and Accountability",
        "nistControl": "AU-2"
      }
    },
    {
      "id": "AU-3-Q1",
      "controlId": "AU-3",
      "text": "Do audit records contain sufficient information for forensic analysis?",
      "impact": "Detailed audit records enable incident investigation",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Insufficient audit record content",
        "description": "Audit records lack necessary detail for forensic analysis",
        "severity": "high",
        "recommendation": "Configure audit logging to capture all required information",
        "category": "Audit and Accountability",
        "nistControl": "AU-3"
      }
    },
    {
      "id": "AU-6-Q1",
      "controlId": "AU-6",
      "text": "Is there a process for regular audit log review and analysis?",
      "impact": "Regular log review helps detect security incidents",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Inadequate audit log review",
        "description": "Organization lacks regular audit log review process",
        "severity": "high",
        "recommendation": "Implement regular audit log review procedures",
        "category": "Audit and Accountability",
        "nistControl": "AU-6"
      }
    },
    {
      "id": "AU-8-Q1",
      "controlId": "AU-8",
      "text": "Are system clocks synchronized across all systems for accurate timestamps?",
      "impact": "Time synchronization ensures accurate event correlation",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Lack of time synchronization",
        "description": "System clocks not properly synchronized",
        "severity": "medium",
        "recommendation": "Implement NTP or similar time synchronization",
        "category": "Audit and Accountability",
        "nistControl": "AU-8"
      }
    },
    {
      "id": "AU-9-Q1",
      "controlId": "AU-9",
      "text": "Are audit records protected from unauthorized access and modification?",
      "impact": "Protected audit records maintain integrity of security monitoring",
      "category": "Audit and Accountability",
      "findingTemplate": {
        "title": "Unprotected audit records",
        "description": "Audit records not adequately protected from tampering",
        "severity": "high",
        "recommendation": "Implement audit record protection mechanisms",
        "category": "Audit and Accountability",
        "nistControl": "AU-9"
      }
    },
    {
      "id": "CM-2-Q1",
      "controlId": "CM-2",
      "text": "Is there a documented baseline configuration for all systems?",
      "impact": "Baseline configurations ensure consistent security",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Missing baseline configurations",
        "description": "Systems lack documented baseline configurations",
        "severity": "high",
        "recommendation": "Develop and maintain baseline configurations for all systems",
        "category": "Configuration Management",
        "nistControl": "CM-2"
      }
    },
    {
      "id": "CM-3-Q1",
      "controlId": "CM-3",
      "text": "Is there a change management process for system modifications?",
      "impact": "Change management prevents unauthorized changes",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Inadequate change management",
        "description": "Organization lacks proper change management process",
        "severity": "high",
        "recommendation": "Implement formal change management procedures",
        "category": "Configuration Management",
        "nistControl": "CM-3"
      }
    },
    {
      "id": "CM-6-Q1",
      "controlId": "CM-6",
      "text": "Are configuration settings monitored and controlled?",
      "impact": "Configuration control maintains security posture",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Insufficient configuration control",
        "description": "Configuration settings not properly monitored or controlled",
        "severity": "high",
        "recommendation": "Implement configuration monitoring and control",
        "category": "Configuration Management",
        "nistControl": "CM-6"
      }
    },
    {
      "id": "CM-7-Q1",
      "controlId": "CM-7",
      "text": "Is the principle of least functionality enforced through application whitelisting?",
      "impact": "Least functionality reduces attack surface",
      "category": "Configuration Management",
      "findingTemplate": {
        "title": "Missing application whitelisting",
        "description": "Systems do not enforce least functionality through whitelisting",
        "severity": "high",
        "recommendation": "Implement application whitelisting",
        "category": "Configuration Management",
        "nistControl": "CM-7"
      }
    },
    {
      "id": "IA-2-Q1",
      "controlId": "IA-2",
      "text": "Is multi-factor authentication required for all privileged accounts?",
      "impact": "MFA protects privileged access from compromise",
      "category": "Identification and Authentication",
      "findingTemplate": {
        "title": "Missing MFA for privileged accounts",
        "description": "Privileged accounts not protected by multi-factor authentication",
        "severity": "critical",
        "recommendation": "Implement MFA for all privileged account access",
        "category": "Identification and Authentication",
        "nistControl": "IA-2"
      }
    },
    {
      "id": "IA-4-Q1",
      "controlId": "IA-4",
      "text": "Are unique identifiers assigned to all system users?",
      "impact": "Unique identifiers ensure accountability",
      "category": "Identification and Authentication",
      "findingTemplate": {
        "title": "Non-unique user identifiers",
        "description": "System users not assigned unique identifiers",
        "severity": "high",
        "recommendation": "Implement unique identifier assignment process",
        "category": "Identification and Authentication",
        "nistControl": "IA-4"
      }
    },
    {
      "id": "IA-5-Q1",
      "controlId": "IA-5",
      "text": "Are password complexity and lifetime restrictions enforced?",
      "impact": "Strong passwords reduce risk of compromise",
      "category": "Identification and Authentication",
      "findingTemplate": {
        "title": "Weak password requirements",
        "description": "Password policies do not enforce adequate complexity or rotation",
        "severity": "high",
        "recommendation": "Implement strong password policies",
        "category": "Identification and Authentication",
        "nistControl": "IA-5"
      }
    },
    {
      "id": "IR-4-Q1",
      "controlId": "IR-4",
      "text": "Is there an incident handling capability in place?",
      "impact": "Incident handling ensures proper response to security events",
      "category": "Incident Response",
      "findingTemplate": {
        "title": "Missing incident handling capability",
        "description": "Organization lacks proper incident handling procedures",
        "severity": "high",
        "recommendation": "Establish incident handling capability",
        "category": "Incident Response",
        "nistControl": "IR-4"
      }
    },
    {
      "id": "IR-5-Q1",
      "controlId": "IR-5",
      "text": "Are security incidents tracked and documented?",
      "impact": "Incident tracking enables trend analysis and improvement",
      "category": "Incident Response",
      "findingTemplate": {
        "title": "Inadequate incident tracking",
        "description": "Security incidents not properly tracked and documented",
        "severity": "high",
        "recommendation": "Implement incident tracking system",
        "category": "Incident Response",
        "nistControl": "IR-5"
      }
    },
    {
      "id": "IR-6-Q1",
      "controlId": "IR-6",
      "text": "Is there a process for incident reporting?",
      "impact": "Incident reporting ensures timely response",
      "category": "Incident Response",
      "findingTemplate": {
        "title": "Missing incident reporting process",
        "description": "Organization lacks formal incident reporting procedures",
        "severity": "high",
        "recommendation": "Establish incident reporting procedures",
        "category": "Incident Response",
        "nistControl": "IR-6"
      }
    },
    {
      "id": "SC-7-Q1",
      "controlId": "SC-7",
      "text": "Are boundary protection mechanisms implemented?",
      "impact": "Boundary protection prevents unauthorized network access",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Insufficient boundary protection",
        "description": "System boundaries lack proper protection mechanisms",
        "severity": "high",
        "recommendation": "Implement boundary protection controls",
        "category": "System and Communications Protection",
        "nistControl": "SC-7"
      }
    },
    {
      "id": "SC-8-Q1",
      "controlId": "SC-8",
      "text": "Is transmission confidentiality and integrity protected?",
      "impact": "Protected transmission prevents data compromise",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Unprotected data transmission",
        "description": "Data transmission lacks confidentiality and integrity protection",
        "severity": "high",
        "recommendation": "Implement transmission protection mechanisms",
        "category": "System and Communications Protection",
        "nistControl": "SC-8"
      }
    },
    {
      "id": "SC-12-Q1",
      "controlId": "SC-12",
      "text": "Are cryptographic keys properly managed throughout their lifecycle?",
      "impact": "Key management ensures cryptographic security",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Inadequate cryptographic key management",
        "description": "Cryptographic keys not properly managed",
        "severity": "high",
        "recommendation": "Implement cryptographic key management procedures",
        "category": "System and Communications Protection",
        "nistControl": "SC-12"
      }
    },
    {
      "id": "SC-13-Q1",
      "controlId": "SC-13",
      "text": "Are FIPS-validated or NSA-approved cryptography used?",
      "impact": "Approved cryptography ensures adequate protection",
      "category": "System and Communications Protection",
      "findingTemplate": {
        "title": "Non-approved cryptography",
        "description": "System uses non-approved cryptographic algorithms",
        "severity": "high",
        "recommendation": "Implement FIPS-validated cryptography",
        "category": "System and Communications Protection",
        "nistControl": "SC-13"
      }
    },
    {
      "id": "SI-2-Q1",
      "controlId": "SI-2",
      "text": "Are system flaws identified and corrected?",
      "impact": "Flaw remediation prevents exploitation",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Inadequate flaw remediation",
        "description": "System flaws not properly identified and corrected",
        "severity": "high",
        "recommendation": "Implement flaw remediation process",
        "category": "System and Information Integrity",
        "nistControl": "SI-2"
      }
    },
    {
      "id": "SI-3-Q1",
      "controlId": "SI-3",
      "text": "Is malicious code protection implemented and updated?",
      "impact": "Malware protection prevents system compromise",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Insufficient malware protection",
        "description": "Systems lack adequate malicious code protection",
        "severity": "high",
        "recommendation": "Implement comprehensive malware protection",
        "category": "System and Information Integrity",
        "nistControl": "SI-3"
      }
    },
    {
      "id": "SI-4-Q1",
      "controlId": "SI-4",
      "text": "Is system monitoring capability implemented?",
      "impact": "Monitoring detects potential security violations",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Insufficient system monitoring",
        "description": "System lacks proper monitoring capability",
        "severity": "high",
        "recommendation": "Implement comprehensive system monitoring",
        "category": "System and Information Integrity",
        "nistControl": "SI-4"
      }
    },
    {
      "id": "SI-5-Q1",
      "controlId": "SI-5",
      "text": "Are security alerts and advisories monitored and acted upon?",
      "impact": "Security alerts enable timely response to threats",
      "category": "System and Information Integrity",
      "findingTemplate": {
        "title": "Inadequate security alert monitoring",
        "description": "Organization does not properly monitor or respond to security alerts",
        "severity": "high",
        "recommendation": "Implement security alert monitoring and response procedures",
        "category": "System and Information Integrity",
        "nistControl": "SI-5"
      }
    }
  ],
  "assessmentHistory": [
    {
      "id": "asmt-001",
      "date": "2025-02-01T08:00:00Z",
      "type": "basic",
      "name": "Basic Security Assessment Feb 2025",
      "score": 75,
      "status": "completed",
      "clientId": 1,
      "systemId": "sys-001",
      "answers": [
        {
          "questionId": 1,
          "questionType": "basic",
          "answer": "no",
          "notes": "Antivirus software outdated on 30% of systems"
        },
        {
          "questionId": 2,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Firewalls properly configured"
        },
        {
          "questionId": 3,
          "questionType": "basic",
          "answer": "no",
          "notes": "MFA not implemented on development systems"
        },
        {
          "questionId": 4,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Password policies enforced through AD"
        },
        {
          "questionId": 5,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Monthly training sessions conducted"
        },
        {
          "questionId": 6,
          "questionType": "basic",
          "answer": "no",
          "notes": "Backup testing not performed regularly"
        },
        {
          "questionId": 7,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Encryption implemented for all sensitive data"
        },
        {
          "questionId": 8,
          "questionType": "basic",
          "answer": "yes",
          "notes": "Regular patch management in place"
        }
      ],
      "generatedFindings": [
        {
          "id": "f-001",
          "sourceQuestionId": 1,
          "questionType": "basic",
          "title": "Missing or outdated antivirus protection",
          "description": "Systems lack proper antivirus protection or updates are not maintained",
          "severity": "high",
          "category": "System Security",
          "recommendation": "Install and configure antivirus software on all systems with automatic updates",
          "status": "open",
          "createdDate": "2025-02-01T08:00:00Z"
        },
        {
          "id": "f-002",
          "sourceQuestionId": 6,
          "questionType": "basic",
          "title": "Insufficient backup procedures",
          "description": "Backup processes are not adequate or tested",
          "severity": "high",
          "category": "Data Protection",
          "recommendation": "Implement comprehensive backup strategy with regular testing",
          "status": "in_progress",
          "createdDate": "2025-02-01T08:00:00Z"
        }
      ]
    },
    {
      "id": "asmt-002",
      "date": "2025-02-15T10:00:00Z",
      "type": "advanced",
      "name": "NIST 800-53 Assessment Feb 2025",
      "score": 82,
      "status": "completed",
      "clientId": 1,
      "systemId": "sys-001",
      "answers": [
        {
          "questionId": "AU-2-Q1",
          "questionType": "advanced",
          "answer": "no",
          "notes": "Audit logging not configured on all systems"
        },
        {
          "questionId": "CM-2-Q1",
          "questionType": "advanced",
          "answer": "no",
          "notes": "Baseline configurations not documented"
        },
        {
          "questionId": "SI-4-Q1",
          "questionType": "advanced",
          "answer": "partial",
          "notes": "Monitoring implemented but not comprehensive"
        },
        {
          "questionId": "AC-2-Q1",
          "questionType": "advanced",
          "answer": "yes",
          "notes": "Automated account management implemented"
        },
        {
          "questionId": "SC-7-Q1",
          "questionType": "advanced",
          "answer": "yes",
          "notes": "Boundary protection mechanisms in place"
        }
      ],
      "generatedFindings": [
        {
          "id": "f-003",
          "sourceQuestionId": "AU-2-Q1",
          "questionType": "advanced",
          "title": "Inadequate audit logging",
          "description": "Systems do not have proper audit event logging configured",
          "severity": "high",
          "category": "Audit and Accountability",
          "recommendation": "Define and implement comprehensive audit logging",
          "status": "completed",
          "createdDate": "2025-02-15T10:00:00Z",
          "nistControl": "AU-2"
        },
        {
          "id": "f-004",
          "sourceQuestionId": "CM-2-Q1",
          "questionType": "advanced",
          "title": "Missing baseline configurations",
          "description": "Systems lack documented baseline configurations",
          "severity": "high",
          "category": "Configuration Management",
          "recommendation": "Develop and maintain baseline configurations for all systems",
          "status": "open",
          "createdDate": "2025-02-15T10:00:00Z",
          "nistControl": "CM-2"
        },
        {
          "id": "f-005",
          "sourceQuestionId": "SI-4-Q1",
          "questionType": "advanced",
          "title": "Insufficient system monitoring",
          "description": "System lacks proper monitoring capability",
          "severity": "high",
          "category": "System and Information Integrity",
          "recommendation": "Implement comprehensive system monitoring",
          "status": "in_progress",
          "createdDate": "2025-02-15T10:00:00Z",
          "nistControl": "SI-4"
        }
      ]
    }
  ],
  "authorizationPackages": [
    {
      "id": "1",
      "systemId": "sys-001",
      "clientId": 1,
      "completed": [
        "System Security Plan",
        "Risk Assessment Report"
      ],
      "pending": [
        "Privacy Impact Assessment",
        "Contingency Plan"
      ],
      "executiveSummary": "System implements moderate security controls with some gaps identified.",
      "status": "in-progress",
      "validationStatus": "pending",
      "completionPercentage": 65,
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "authorizationDecisions": [
    {
      "id": "1",
      "systemId": "sys-001",
      "clientId": 1,
      "result": "pending",
      "official": "",
      "date": "",
      "expirationDate": "",
      "justification": "",
      "conditions": [],
      "boundary": "System includes all components within the development network segment.",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "authorizationRisks": [
    {
      "id": "RISK-001",
      "systemId": "sys-001",
      "clientId": 1,
      "description": "Insufficient access controls",
      "likelihood": "high",
      "impact": "high",
      "status": "open",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "nonCompliantControls": [
    {
      "id": "1",
      "systemId": "sys-001",
      "clientId": 1,
      "controlId": "AC-2",
      "title": "Account Management",
      "status": "non-compliant",
      "findings": "Missing automated account management procedures",
      "createdAt": "2024-02-10",
      "updatedAt": "2024-02-10"
    }
  ],
  "basicQuestions": [
    {
      "id": "1",
      "text": "Is antivirus software installed and updated on all systems?",
      "impact": "Antivirus helps protect against malware and cyber threats",
      "category": "System Security",
      "findingTemplate": {
        "title": "Missing or outdated antivirus protection",
        "description": "Systems lack proper antivirus protection or updates are not maintained",
        "severity": "high",
        "recommendation": "Install and configure antivirus software on all systems with automatic updates",
        "category": "System Security"
      }
    },
    {
      "id": "2",
      "text": "Are firewalls configured and maintained on all network boundaries?",
      "impact": "Firewalls help prevent unauthorized network access",
      "category": "Network Security",
      "findingTemplate": {
        "title": "Inadequate firewall protection",
        "description": "Network boundaries lack proper firewall configuration",
        "severity": "high",
        "recommendation": "Deploy and configure firewalls at all network boundaries",
        "category": "Network Security"
      }
    },
    {
      "id": "3",
      "text": "Is multi-factor authentication (MFA) enabled for all critical systems?",
      "impact": "MFA significantly reduces the risk of unauthorized access",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Missing Multi-Factor Authentication",
        "description": "Critical systems lack MFA protection",
        "severity": "high",
        "recommendation": "Implement MFA for all critical system access",
        "category": "Access Control"
      }
    },
    {
      "id": "4",
      "text": "Are password policies enforced across all systems?",
      "impact": "Strong password policies are essential for access security",
      "category": "Access Control",
      "findingTemplate": {
        "title": "Insufficient password policies",
        "description": "Password policies do not meet security requirements",
        "severity": "high",
        "recommendation": "Implement and enforce strong password policies",
        "category": "Access Control"
      }
    },
    {
      "id": "5",
      "text": "Is security awareness training provided regularly?",
      "impact": "Training helps prevent social engineering attacks",
      "category": "Security Awareness",
      "findingTemplate": {
        "title": "Inadequate security awareness training",
        "description": "Security awareness training is not regularly conducted",
        "severity": "medium",
        "recommendation": "Implement regular security awareness training program",
        "category": "Security Awareness"
      }
    },
    {
      "id": "6",
      "text": "Are regular backups performed and tested?",
      "impact": "Backups are critical for business continuity",
      "category": "Data Protection",
      "findingTemplate": {
        "title": "Insufficient backup procedures",
        "description": "Backup processes are not adequate or tested",
        "severity": "high",
        "recommendation": "Implement comprehensive backup strategy with regular testing",
        "category": "Data Protection"
      }
    },
    {
      "id": "7",
      "text": "Is sensitive data encrypted at rest and in transit?",
      "impact": "Encryption protects data from unauthorized access",
      "category": "Data Protection",
      "findingTemplate": {
        "title": "Inadequate data encryption",
        "description": "Sensitive data is not properly encrypted",
        "severity": "high",
        "recommendation": "Implement encryption for data at rest and in transit",
        "category": "Data Protection"
      }
    },
    {
      "id": "8",
      "text": "Is patch management performed regularly?",
      "impact": "Regular patching prevents exploitation of known vulnerabilities",
      "category": "System Security",
      "findingTemplate": {
        "title": "Inadequate patch management",
        "description": "Systems are not patched regularly",
        "severity": "high",
        "recommendation": "Implement regular patch management process",
        "category": "System Security"
      }
    }
  ],
  "controls": [
    {
      "id": "AC-1",
      "title": "Access Control Policy and Procedures",
      "status": "Compliant",
      "evidence": "Access Control Policy v2.1 implemented and reviewed",
      "notes": "Annual review completed",
      "lastUpdated": "2025-02-10T09:00:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-10T09:00:00Z",
      "updatedAt": "2025-02-10T09:00:00Z"
    },
    {
      "id": "AC-2",
      "title": "Account Management",
      "status": "Non-Compliant",
      "evidence": "Automated account review process not implemented",
      "notes": "Implementation in progress",
      "lastUpdated": "2025-02-11T15:30:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-11T15:30:00Z",
      "updatedAt": "2025-02-11T15:30:00Z"
    },
    {
      "id": "AC-3",
      "title": "Access Enforcement",
      "status": "Compliant",
      "evidence": "Role-based access control implemented",
      "notes": "Verified during testing",
      "lastUpdated": "2025-02-12T11:20:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-12T11:20:00Z",
      "updatedAt": "2025-02-12T11:20:00Z"
    },
    {
      "id": "AC-4",
      "title": "Information Flow Enforcement",
      "status": "Not-Applicable",
      "evidence": "System does not process classified information",
      "notes": "Approved deviation",
      "lastUpdated": "2025-02-13T14:15:00Z",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-13T14:15:00Z",
      "updatedAt": "2025-02-13T14:15:00Z"
    }
  ],
  "assessmentDocuments": [
    {
      "id": "doc-001",
      "name": "System Security Plan",
      "expirationDate": "2026-02-20",
      "lastReviewed": "2025-02-15",
      "validationNotes": "Annual review completed. Updates required for new controls.",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2025-02-15",
          "notes": "Annual review completed. Updates required for new controls."
        },
        {
          "id": 2,
          "date": "2024-02-15",
          "notes": "Initial review completed."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-02-15T00:00:00Z",
      "updatedAt": "2025-02-15T00:00:00Z"
    },
    {
      "id": "doc-002",
      "name": "Incident Response Plan",
      "expirationDate": "2025-03-15",
      "lastReviewed": "2024-03-15",
      "validationNotes": "Review needed before expiration",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2024-03-15",
          "notes": "Annual review completed. No major changes required."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-03-15T00:00:00Z",
      "updatedAt": "2024-03-15T00:00:00Z"
    },
    {
      "id": "doc-003",
      "name": "Contingency Plan",
      "expirationDate": "2025-01-10",
      "lastReviewed": "2024-01-10",
      "validationNotes": "Document expired. Immediate review required.",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2024-01-10",
          "notes": "Annual review completed. Updated recovery procedures."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-01-10T00:00:00Z",
      "updatedAt": "2024-01-10T00:00:00Z"
    },
    {
      "id": "doc-004",
      "name": "Configuration Management Plan",
      "expirationDate": "2025-06-30",
      "lastReviewed": "2024-06-30",
      "validationNotes": "Current and valid",
      "reviewHistory": [
        {
          "id": 1,
          "date": "2024-06-30",
          "notes": "Updated to include new system components."
        }
      ],
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2024-06-30T00:00:00Z",
      "updatedAt": "2024-06-30T00:00:00Z"
    }
  ],
  "assessmentPlans": [
    {
      "id": "ap-001",
      "assessmentTitle": "Annual Security Assessment 2025",
      "assessmentType": "Annual Assessment",
      "startDate": "2025-01-01",
      "endDate": "2025-03-31",
      "assessmentTeam": "Security Team A\nExternal Auditor: SecureAudit Inc.",
      "objectives": "Evaluate system security controls\nValidate compliance with security requirements\nIdentify potential vulnerabilities",
      "methodology": "NIST SP 800-53A Rev 5\nAutomated scanning\nManual testing\nDocument review",
      "scope": "All production systems\nNetwork infrastructure\nAccess controls\nSecurity policies",
      "requirements": "NIST 800-53 Low baseline\nOrganizational security policies\nRegulatory requirements",
      "status": "in-progress",
      "clientId": 1,
      "systemId": "sys-001",
      "createdAt": "2025-01-01T00:00:00Z",
      "updatedAt": "2025-02-19T10:00:00Z"
    }
  ],
  "scanResults": [
    {
      "id": "scan-001",
      "type": "STIG Scan",
      "date": "2025-02-15T10:00:00Z",
      "findings": {
        "high": 2,
        "medium": 5,
        "low": 8
      },
      "status": "Completed",
      "downloadUrl": "#",
      "detailsUrl": "#",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-15T10:00:00Z",
      "updatedAt": "2025-02-15T10:00:00Z"
    },
    {
      "id": "scan-002",
      "type": "SCAP Scan",
      "date": "2025-02-01T14:30:00Z",
      "findings": {
        "high": 1,
        "medium": 3,
        "low": 6
      },
      "status": "Completed",
      "downloadUrl": "#",
      "detailsUrl": "#",
      "clientId": 1,
      "systemId": "sys-001",
      "assessmentPlanId": "ap-001",
      "createdAt": "2025-02-01T14:30:00Z",
      "updatedAt": "2025-02-01T14:30:00Z"
    }
  ],
  "roles": [
    {
      "id": "PROGRAM_MANAGER",
      "name": "PROGRAM_MANAGER"
    },
    {
      "id": "ISSM",
      "name": "ISSM"
    },
    {
      "id": "ISSO",
      "name": "ISSO"
    },
    {
      "id": "ISSE",
      "name": "ISSE"
    },
    {
      "id": "SYSTEM_ADMIN",
      "name": "SYSTEM_ADMIN"
    }
  ],
  "permissions": [
    {
      "id": "all",
      "description": "Full system access with no restrictions",
      "name": "all"
    },
    {
      "id": "view",
      "description": "Read-only access to system information"
    },
    {
      "id": "edit",
      "description": "Ability to modify system information"
    },
    {
      "id": "approve",
      "description": "Authority to approve system changes and assessments"
    },
    {
      "id": "review",
      "description": "Ability to review and comment on system documentation"
    },
    {
      "id": "assess",
      "description": "Permission to perform security assessments"
    },
    {
      "id": "manage_users",
      "name": "manage_users"
    },
    {
      "id": "view_users",
      "name": "view_users"
    },
    {
      "id": "manage_systems",
      "name": "manage_systems"
    },
    {
      "id": "view_systems",
      "name": "view_systems"
    },
    {
      "id": "manage_audits",
      "name": "manage_audits"
    },
    {
      "id": "view_audits",
      "name": "view_audits"
    },
    {
      "id": "manage_strategy",
      "name": "manage_strategy"
    }
  ],
  "users": [
    {
      "id": "1",
      "email": "senior.ao@example.com",
      "password": "password123",
      "firstName": "John",
      "lastName": "Smith",
      "role": "SENIOR_AO",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2025-02-24T18:12:30.637Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0123",
      "department": "Executive",
      "title": "Senior Authorizing Official",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "light",
        "language": "en"
      }
    },
    {
      "id": "2",
      "email": "sao@example.com",
      "password": "password123",
      "firstName": "Jane",
      "lastName": "Doe",
      "role": "SUBORDINATE_AO",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0124",
      "department": "Authorization",
      "title": "Subordinate Authorizing Official",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "light",
        "language": "en"
      }
    },
    {
      "id": "3",
      "email": "aodr@example.com",
      "password": "password123",
      "firstName": "Mike",
      "lastName": "Johnson",
      "role": "AODR",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0125",
      "department": "Authorization",
      "title": "AO Designated Representative",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "dark",
        "language": "en"
      }
    },
    {
      "id": "4",
      "email": "sca@example.com",
      "password": "password123",
      "firstName": "Sarah",
      "lastName": "Wilson",
      "role": "SCA",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0126",
      "department": "Security Assessment",
      "title": "Security Control Assessor",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "light",
        "language": "en"
      }
    },
    {
      "id": "5",
      "email": "scar@example.com",
      "password": "password123",
      "firstName": "David",
      "lastName": "Brown",
      "role": "SCAR",
      "isActive": true,
      "lastLogin": "2024-02-19T12:00:00Z",
      "lastActive": "2024-02-19T12:00:00Z",
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-02-19T12:00:00Z",
      "profileImage": null,
      "phoneNumber": "+1-555-0127",
      "department": "Security Assessment",
      "title": "Security Control Assessor Representative",
      "status": "active",
      "failedLoginAttempts": 0,
      "lastPasswordChange": "2024-01-01T00:00:00Z",
      "preferences": {
        "notifications": true,
        "theme": "dark",
        "language": "en"
      }
    },
    {
      "id": "1",
      "username": "john.smith",
      "email": "john.smith@acme.com",
      "role": "PROGRAM_MANAGER",
      "clientId": 1,
      "firstName": "John",
      "lastName": "Smith",
      "title": "Program Manager",
      "department": "Security",
      "phone": "(555) 123-4567",
      "isActive": true,
      "lastActive": "2024-02-19T10:00:00Z",
      "permissions": [
        "manage_users",
        "manage_systems",
        "view_audits",
        "manage_strategy"
      ]
    },
    {
      "id": "2",
      "username": "sarah.johnson",
      "email": "sarah.johnson@acme.com",
      "role": "ISSM",
      "clientId": 1,
      "firstName": "Sarah",
      "lastName": "Johnson",
      "title": "Information System Security Manager",
      "department": "Security",
      "phone": "(555) 234-5678",
      "isActive": true,
      "lastActive": "2024-02-19T09:00:00Z",
      "permissions": [
        "manage_users",
        "manage_systems",
        "manage_audits",
        "manage_strategy"
      ]
    },
    {
      "id": "3",
      "username": "mike.wilson",
      "email": "mike.wilson@acme.com",
      "role": "ISSO",
      "clientId": 1,
      "firstName": "Mike",
      "lastName": "Wilson",
      "title": "Information System Security Officer",
      "department": "IT",
      "phone": "(555) 345-6789",
      "isActive": true,
      "lastActive": "2024-02-19T08:00:00Z",
      "permissions": [
        "view_users",
        "manage_systems",
        "manage_audits"
      ]
    },
    {
      "id": "4",
      "username": "alice.brown",
      "email": "alice.brown@healthcareplus.com",
      "role": "PROGRAM_MANAGER",
      "clientId": 2,
      "firstName": "Alice",
      "lastName": "Brown",
      "title": "Security Program Manager",
      "department": "Security",
      "phone": "(555) 456-7890",
      "isActive": true,
      "lastActive": "2024-02-19T11:00:00Z",
      "permissions": [
        "manage_users",
        "manage_systems",
        "view_audits",
        "manage_strategy"
      ]
    },
    {
      "id": "5",
      "username": "admin",
      "email": "admin@grc.com",
      "role": "SYSTEM_ADMIN",
      "clientId": null,
      "firstName": "System",
      "lastName": "Administrator",
      "title": "System Administrator",
      "department": "IT",
      "phone": "(555) 999-9999",
      "isActive": true,
      "lastActive": "2024-02-19T12:00:00Z",
      "permissions": [
        "all"
      ]
    }
  ],
  "statuses": [
    {
      "id": "active",
      "description": "User account is active and accessible"
    },
    {
      "id": "inactive",
      "description": "User account has been deactivated"
    },
    {
      "id": "suspended",
      "description": "User account has been temporarily suspended"
    },
    {
      "id": "pending_activation",
      "description": "User account awaiting activation"
    }
  ],
  "preferences": {
    "themes": [
      {
        "id": "light",
        "name": "Light Theme",
        "description": "Default light color scheme"
      },
      {
        "id": "dark",
        "name": "Dark Theme",
        "description": "Dark color scheme for low-light environments"
      }
    ],
    "languages": [
      {
        "id": "en",
        "name": "English",
        "code": "en-US"
      },
      {
        "id": "es",
        "name": "Spanish",
        "code": "es-ES"
      },
      {
        "id": "fr",
        "name": "French",
        "code": "fr-FR"
      }
    ],
    "notificationTypes": [
      {
        "id": "email",
        "name": "Email Notifications",
        "description": "Receive notifications via email"
      },
      {
        "id": "in-app",
        "name": "In-App Notifications",
        "description": "Receive notifications within the application"
      },
      {
        "id": "sms",
        "name": "SMS Notifications",
        "description": "Receive notifications via text message"
      }
    ]
  },
  "clients": [
    {
      "id": "1",
      "name": "Acme Corporation",
      "industry": "Technology",
      "email": "contact@acme.com",
      "phone": "(555) 123-4567",
      "primaryContact": "John Smith",
      "createdAt": "2024-01-01T10:00:00Z",
      "lastActivity": "2024-02-19T10:00:00Z",
      "complianceScore": 85,
      "status": "active",
      "address": {
        "street": "123 Tech Lane",
        "city": "San Francisco",
        "state": "CA",
        "zip": "94105",
        "country": "USA"
      },
      "size": "Enterprise",
      "employeeCount": 5000,
      "website": "www.acme.com"
    }
  ],
  "rolePermissions": [
    {
      "id": "PROGRAM_MANAGER",
      "permissions": [
        "manage_users",
        "manage_systems",
        "view_audits",
        "manage_strategy"
      ]
    },
    {
      "id": "ISSM",
      "permissions": [
        "manage_users",
        "manage_systems",
        "manage_audits",
        "manage_strategy"
      ]
    },
    {
      "id": "ISSO",
      "permissions": [
        "view_users",
        "manage_systems",
        "manage_audits"
      ]
    },
    {
      "id": "ISSE",
      "permissions": [
        "view_users",
        "view_systems",
        "view_audits"
      ]
    },
    {
      "id": "SYSTEM_ADMIN",
      "permissions": [
        "all"
      ]
    }
  ],
  "departments": [
    {
      "id": "Security",
      "name": "Security"
    },
    {
      "id": "IT",
      "name": "IT"
    },
    {
      "id": "Compliance",
      "name": "Compliance"
    },
    {
      "id": "Risk Management",
      "name": "Risk Management"
    },
    {
      "id": "Operations",
      "name": "Operations"
    },
    {
      "id": "Executive",
      "name": "Executive"
    },
    {
      "id": "1",
      "clientId": 1,
      "name": "Information Technology",
      "head": "David Wilson",
      "headTitle": "CTO",
      "employeeCount": 150,
      "positions": [
        {
          "id": 1,
          "name": "Software Engineer"
        },
        {
          "id": 2,
          "name": "System Administrator"
        },
        {
          "id": 3,
          "name": "Security Analyst"
        }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    },
    {
      "id": "2",
      "clientId": 1,
      "name": "Security Operations",
      "head": "Alice Brown",
      "headTitle": "CISO",
      "employeeCount": 50,
      "positions": [
        {
          "id": 1,
          "name": "Security Engineer"
        },
        {
          "id": 2,
          "name": "Incident Responder"
        },
        {
          "id": 3,
          "name": "Security Analyst"
        }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    },
    {
      "id": "3",
      "clientId": 1,
      "name": "Risk & Compliance",
      "head": "Michael Chen",
      "headTitle": "Risk Director",
      "employeeCount": 35,
      "positions": [
        {
          "id": 1,
          "name": "Risk Analyst"
        },
        {
          "id": 2,
          "name": "Compliance Officer"
        },
        {
          "id": 3,
          "name": "Auditor"
        }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    },
    {
      "id": "4",
      "clientId": 1,
      "name": "Network Operations",
      "head": "Sarah Johnson",
      "headTitle": "Network Director",
      "employeeCount": 45,
      "positions": [
        {
          "id": 1,
          "name": "Network Engineer"
        },
        {
          "id": 2,
          "name": "Infrastructure Specialist"
        },
        {
          "id": 3,
          "name": "Cloud Architect"
        }
      ],
      "lastUpdated": "2024-02-19T10:00:00Z"
    }
  ],
  "titles": [
    {
      "id": "Program Manager",
      "name": "Program Manager"
    },
    {
      "id": "Information System Security Manager",
      "name": "Information System Security Manager"
    },
    {
      "id": "Information System Security Officer",
      "name": "Information System Security Officer"
    },
    {
      "id": "Security Engineer",
      "name": "Security Engineer"
    },
    {
      "id": "System Administrator",
      "name": "System Administrator"
    },
    {
      "id": "Security Analyst",
      "name": "Security Analyst"
    },
    {
      "id": "Compliance Officer",
      "name": "Compliance Officer"
    },
    {
      "id": "Risk Manager",
      "name": "Risk Manager"
    }
  ],
  "userStatus": [
    {
      "id": "active",
      "name": "active"
    },
    {
      "id": "inactive",
      "name": "inactive"
    },
    {
      "id": "suspended",
      "name": "suspended"
    },
    {
      "id": "pending",
      "name": "pending"
    }
  ],
  "documents": [
    {
      "id": "1",
      "clientId": 1,
      "name": "Security Policy.pdf",
      "type": "PDF",
      "lastUpdated": "2024-02-19T10:00:00Z",
      "category": "Policies",
      "size": 2500000,
      "uploadedBy": "John Smith"
    },
    {
      "id": "2",
      "clientId": 1,
      "name": "Incident Response Plan.docx",
      "type": "DOCX",
      "lastUpdated": "2024-02-18T10:00:00Z",
      "category": "Procedures",
      "size": 1800000,
      "uploadedBy": "Alice Brown"
    },
    {
      "id": "3",
      "clientId": 1,
      "name": "Risk Assessment Report.pdf",
      "type": "PDF",
      "lastUpdated": "2024-02-19T09:00:00Z",
      "category": "Reports",
      "size": 3200000,
      "uploadedBy": "Michael Chen"
    },
    {
      "id": "4",
      "clientId": 1,
      "name": "Network Security Architecture.pptx",
      "type": "PPT",
      "lastUpdated": "2024-02-17T14:00:00Z",
      "category": "Documentation",
      "size": 4500000,
      "uploadedBy": "Sarah Johnson"
    },
    {
      "id": "5",
      "clientId": 1,
      "name": "Security Training Materials.zip",
      "type": "ZIP",
      "lastUpdated": "2024-02-16T11:00:00Z",
      "category": "Training",
      "size": 15000000,
      "uploadedBy": "David Wilson"
    }
  ],
  "keyPersonnel": [
    {
      "id": "1",
      "clientId": 1,
      "departmentId": null,
      "name": "John Smith",
      "role": "Primary Contact",
      "department": "Executive",
      "title": "CEO"
    },
    {
      "id": "2",
      "clientId": 1,
      "departmentId": 1,
      "name": "David Wilson",
      "role": "Technology Lead",
      "department": "Information Technology",
      "title": "CTO"
    },
    {
      "id": "3",
      "clientId": 1,
      "departmentId": 2,
      "name": "Alice Brown",
      "role": "Security Lead",
      "department": "Security Operations",
      "title": "CISO"
    },
    {
      "id": "4",
      "clientId": 1,
      "departmentId": 3,
      "name": "Michael Chen",
      "role": "Risk Lead",
      "department": "Risk & Compliance",
      "title": "Risk Director"
    },
    {
      "id": "5",
      "clientId": 1,
      "departmentId": 4,
      "name": "Sarah Johnson",
      "role": "Infrastructure Lead",
      "department": "Network Operations",
      "title": "Network Director"
    }
  ],
  "industries": [
    {
      "id": "1",
      "name": "Technology"
    },
    {
      "id": "2",
      "name": "Healthcare"
    },
    {
      "id": "3",
      "name": "Financial Services"
    },
    {
      "id": "4",
      "name": "Manufacturing"
    },
    {
      "id": "5",
      "name": "Retail"
    },
    {
      "id": "6",
      "name": "Energy"
    },
    {
      "id": "7",
      "name": "Education"
    },
    {
      "id": "8",
      "name": "Government"
    },
    {
      "id": "9",
      "name": "Non-Profit"
    }
  ],
  "clientSizes": [
    {
      "id": "1",
      "name": "Small"
    },
    {
      "id": "2",
      "name": "Medium"
    },
    {
      "id": "3",
      "name": "Large"
    },
    {
      "id": "4",
      "name": "Enterprise"
    }
  ],
  "clientStatuses": [
    {
      "id": "1",
      "name": "active"
    },
    {
      "id": "2",
      "name": "inactive"
    },
    {
      "id": "3",
      "name": "suspended"
    },
    {
      "id": "4",
      "name": "pending"
    }
  ],
  "documentCategories": [
    {
      "id": "1",
      "name": "Policies"
    },
    {
      "id": "2",
      "name": "Procedures"
    },
    {
      "id": "3",
      "name": "Compliance"
    },
    {
      "id": "4",
      "name": "Reports"
    },
    {
      "id": "5",
      "name": "Training"
    },
    {
      "id": "6",
      "name": "Documentation"
    },
    {
      "id": "7",
      "name": "General"
    }
  ],
  "documentTypes": [
    {
      "id": "1",
      "name": "PDF"
    },
    {
      "id": "2",
      "name": "DOCX"
    },
    {
      "id": "3",
      "name": "XLSX"
    },
    {
      "id": "4",
      "name": "PPT"
    },
    {
      "id": "5",
      "name": "TXT"
    },
    {
      "id": "6",
      "name": "ZIP"
    }
  ],
  "incidentTypes": [
    {
      "id": "1",
      "name": "security"
    },
    {
      "id": "2",
      "name": "system"
    },
    {
      "id": "3",
      "name": "network"
    },
    {
      "id": "4",
      "name": "application"
    },
    {
      "id": "5",
      "name": "hardware"
    },
    {
      "id": "6",
      "name": "software"
    },
    {
      "id": "7",
      "name": "data"
    },
    {
      "id": "8",
      "name": "user"
    },
    {
      "id": "9",
      "name": "other"
    }
  ],
  "incidentSeverities": [
    {
      "id": "1",
      "name": "critical"
    },
    {
      "id": "2",
      "name": "high"
    },
    {
      "id": "3",
      "name": "medium"
    },
    {
      "id": "4",
      "name": "low"
    }
  ],
  "incidentStatuses": [
    {
      "id": "1",
      "name": "active"
    },
    {
      "id": "2",
      "name": "investigating"
    },
    {
      "id": "3",
      "name": "mitigated"
    },
    {
      "id": "4",
      "name": "resolved"
    },
    {
      "id": "5",
      "name": "closed"
    }
  ],
  "incidentPriorities": [
    {
      "id": "1",
      "name": "critical"
    },
    {
      "id": "2",
      "name": "high"
    },
    {
      "id": "3",
      "name": "medium"
    },
    {
      "id": "4",
      "name": "low"
    }
  ],
  "actionTypes": [
    {
      "id": "1",
      "name": "detection"
    },
    {
      "id": "2",
      "name": "investigation"
    },
    {
      "id": "3",
      "name": "mitigation"
    },
    {
      "id": "4",
      "name": "resolution"
    },
    {
      "id": "5",
      "name": "communication"
    },
    {
      "id": "6",
      "name": "escalation"
    }
  ],
  "teams": [
    {
      "id": "1",
      "name": "Information Technology"
    },
    {
      "id": "2",
      "name": "Security Operations"
    },
    {
      "id": "3",
      "name": "Risk & Compliance"
    },
    {
      "id": "4",
      "name": "Network Operations"
    }
  ],
  "systemTypes": [
    {
      "id": "1",
      "name": "Web Server"
    },
    {
      "id": "2",
      "name": "Database Server"
    },
    {
      "id": "3",
      "name": "Authentication Server"
    },
    {
      "id": "4",
      "name": "Network Infrastructure"
    },
    {
      "id": "5",
      "name": "Storage System"
    },
    {
      "id": "6",
      "name": "Backup System"
    },
    {
      "id": "7",
      "name": "End User Systems"
    },
    {
      "id": "8",
      "name": "Security Systems"
    },
    {
      "id": "9",
      "name": "Cloud Services"
    }
  ],
  "incidents": [
    {
      "id": "1",
      "clientId": 1,
      "title": "Unauthorized Access Attempt",
      "type": "security",
      "severity": "high",
      "status": "active",
      "priority": "high",
      "createdAt": "2024-02-19T08:00:00Z",
      "updatedAt": "2024-02-19T10:30:00Z",
      "resolvedAt": null,
      "assignedTo": "Security Operations",
      "description": "Multiple failed login attempts detected from suspicious IP addresses",
      "affectedSystems": [
        "Authentication Server",
        "User Database"
      ],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-19T08:00:00Z",
          "description": "IDS detected multiple failed login attempts",
          "performedBy": "Security Operations"
        },
        {
          "id": 2,
          "type": "mitigation",
          "timestamp": "2024-02-19T08:15:00Z",
          "description": "IP addresses temporarily blocked",
          "performedBy": "Alice Brown"
        },
        {
          "id": 3,
          "type": "investigation",
          "timestamp": "2024-02-19T10:30:00Z",
          "description": "Analysis of login attempt patterns",
          "performedBy": "Security Operations"
        }
      ]
    },
    {
      "id": "2",
      "clientId": 1,
      "title": "Data Backup Failure",
      "type": "system",
      "severity": "medium",
      "status": "resolved",
      "priority": "medium",
      "createdAt": "2024-02-18T15:00:00Z",
      "updatedAt": "2024-02-18T17:45:00Z",
      "resolvedAt": "2024-02-18T17:45:00Z",
      "assignedTo": "Information Technology",
      "description": "Scheduled backup job failed due to storage capacity issues",
      "affectedSystems": [
        "Backup System",
        "Storage System"
      ],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-18T15:00:00Z",
          "description": "Backup job failure alert received",
          "performedBy": "Information Technology"
        },
        {
          "id": 2,
          "type": "investigation",
          "timestamp": "2024-02-18T15:30:00Z",
          "description": "Storage capacity analysis performed",
          "performedBy": "David Wilson"
        },
        {
          "id": 3,
          "type": "resolution",
          "timestamp": "2024-02-18T17:45:00Z",
          "description": "Additional storage allocated and backup job rerun successfully",
          "performedBy": "Information Technology"
        }
      ]
    },
    {
      "id": "3",
      "clientId": 1,
      "title": "SSL Certificate Expiration",
      "type": "security",
      "severity": "medium",
      "status": "active",
      "priority": "high",
      "createdAt": "2024-02-19T09:00:00Z",
      "updatedAt": "2024-02-19T09:30:00Z",
      "resolvedAt": null,
      "assignedTo": "Security Operations",
      "description": "SSL certificate for main website approaching expiration",
      "affectedSystems": [
        "Web Server"
      ],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-19T09:00:00Z",
          "description": "Certificate expiration alert received",
          "performedBy": "Security Operations"
        },
        {
          "id": 2,
          "type": "mitigation",
          "timestamp": "2024-02-19T09:30:00Z",
          "description": "Certificate renewal process initiated",
          "performedBy": "Alice Brown"
        }
      ]
    },
    {
      "id": "4",
      "clientId": 1,
      "title": "Network Performance Degradation",
      "type": "network",
      "severity": "high",
      "status": "investigating",
      "priority": "high",
      "createdAt": "2024-02-19T11:00:00Z",
      "updatedAt": "2024-02-19T11:45:00Z",
      "resolvedAt": null,
      "assignedTo": "Network Operations",
      "description": "Users reporting slow network performance and intermittent connectivity issues",
      "affectedSystems": [
        "Network Infrastructure",
        "Cloud Services"
      ],
      "actions": [
        {
          "id": 1,
          "type": "detection",
          "timestamp": "2024-02-19T11:00:00Z",
          "description": "Multiple user reports of slow network performance",
          "performedBy": "Information Technology"
        },
        {
          "id": 2,
          "type": "investigation",
          "timestamp": "2024-02-19T11:45:00Z",
          "description": "Network monitoring analysis initiated",
          "performedBy": "Sarah Johnson"
        }
      ]
    }
  ],
  "systems": [
    {
      "id": "sys-001",
      "clientId": 1,
      "name": "Core Banking System",
      "description": "Primary banking and transaction processing system",
      "type": "Major Application",
      "status": "active",
      "createdAt": "2024-01-15",
      "updatedAt": "2024-02-10"
    }
  ],
  "enums": {
    "systemStatus": [
      {
        "id": 1,
        "name": "active"
      },
      {
        "id": 2,
        "name": "inactive"
      },
      {
        "id": 3,
        "name": "maintenance"
      },
      {
        "id": 4,
        "name": "retired"
      }
    ],
    "atoStatus": [
      {
        "id": 1,
        "name": "not_started"
      },
      {
        "id": 2,
        "name": "in_progress"
      },
      {
        "id": 3,
        "name": "approved"
      },
      {
        "id": 4,
        "name": "denied"
      },
      {
        "id": 5,
        "name": "expired"
      }
    ],
    "securityLevel": [
      {
        "id": 1,
        "name": "low"
      },
      {
        "id": 2,
        "name": "moderate"
      },
      {
        "id": 3,
        "name": "high"
      }
    ],
    "informationLevel": [
      {
        "id": 1,
        "name": "public"
      },
      {
        "id": 2,
        "name": "internal"
      },
      {
        "id": 3,
        "name": "confidential"
      },
      {
        "id": 4,
        "name": "restricted"
      }
    ],
    "systemCategory": [
      {
        "id": 1,
        "name": "financial"
      },
      {
        "id": 2,
        "name": "operational"
      },
      {
        "id": 3,
        "name": "administrative"
      },
      {
        "id": 4,
        "name": "security"
      }
    ],
    "networkTypes": [
      {
        "id": 1,
        "name": "LAN"
      },
      {
        "id": 2,
        "name": "WAN"
      },
      {
        "id": 3,
        "name": "Cloud"
      },
      {
        "id": 4,
        "name": "VPN"
      },
      {
        "id": 5,
        "name": "DMZ"
      }
    ],
    "componentTypes": [
      {
        "id": 1,
        "name": "Server"
      },
      {
        "id": 2,
        "name": "Database"
      },
      {
        "id": 3,
        "name": "Application"
      },
      {
        "id": 4,
        "name": "Network Device"
      },
      {
        "id": 5,
        "name": "Security Appliance"
      }
    ],
    "procedureTypes": [
      {
        "id": 1,
        "name": "Backup"
      },
      {
        "id": 2,
        "name": "Recovery"
      },
      {
        "id": 3,
        "name": "Maintenance"
      },
      {
        "id": 4,
        "name": "Security"
      },
      {
        "id": 5,
        "name": "Monitoring"
      }
    ]
  },
  "commonPorts": [
    {
      "id": "1",
      "port": 80,
      "service": "HTTP"
    },
    {
      "id": "2",
      "port": 443,
      "service": "HTTPS"
    },
    {
      "id": "3",
      "port": 22,
      "service": "SSH"
    },
    {
      "id": "4",
      "port": 3306,
      "service": "MySQL"
    },
    {
      "id": "5",
      "port": 5432,
      "service": "PostgreSQL"
    }
  ]
}

================
File: mocks/generateDb.js
================
import { readFileSync, readdirSync, statSync, writeFileSync } from 'fs';
import { join, extname } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Function to read JSON file
const readJsonFile = (filePath) => {
  try {
    const data = readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error(`Error reading ${filePath}:`, error);
    return {};
  }
};

// Function to recursively get all JSON files in a directory
const getJsonFiles = (dir) => {
  let results = [];
  const items = readdirSync(dir);

  items.forEach((item) => {
    const fullPath = join(dir, item);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      results = results.concat(getJsonFiles(fullPath));
    } else if (extname(item) === '.json' && item !== 'db.json') {
      results.push(fullPath);
    }
  });

  return results;
};

// Function to merge data preserving and concatenating arrays
const mergeData = (target, source) => {
  if (!target) target = Array.isArray(source) ? [] : {};
  
  Object.keys(source).forEach(key => {
    // Special handling for users array from auth/users.json
    if (key === 'users' && Array.isArray(source[key])) {
      if (!Array.isArray(target[key])) {
        target[key] = [];
      }
      // Add each auth user if they don't already exist
      source[key].forEach(sourceUser => {
        const existingUser = target[key].find(targetUser => 
          targetUser && targetUser.email === sourceUser.email
        );
        if (!existingUser) {
          target[key].push(sourceUser);
        }
      });
    }
    // Handle other arrays
    else if (Array.isArray(source[key])) {
      if (!Array.isArray(target[key])) {
        target[key] = [];
      }
      
      // Merge arrays
      source[key].forEach(sourceItem => {
        if (typeof sourceItem === 'object' && sourceItem !== null && 'id' in sourceItem) {
          // For objects with IDs, update or add
          const existingItem = target[key].find(targetItem => 
            targetItem && typeof targetItem === 'object' && targetItem.id === sourceItem.id
          );
          if (existingItem) {
            Object.assign(existingItem, sourceItem);
          } else {
            target[key].push(sourceItem);
          }
        } else {
          // For primitive values or objects without IDs, just add if not exists
          const exists = target[key].some(targetItem => 
            JSON.stringify(targetItem) === JSON.stringify(sourceItem)
          );
          if (!exists) {
            target[key].push(sourceItem);
          }
        }
      });
    }
    // Handle nested objects
    else if (typeof source[key] === 'object' && source[key] !== null) {
      target[key] = mergeData(target[key] || {}, source[key]);
    }
    // Handle primitive values
    else {
      target[key] = source[key];
    }
  });
  
  return target;
};

// Main function to generate db.json
const generateDb = () => {
  const dataDir = join(__dirname, 'data');
  const outputFile = join(__dirname, 'db.json');
  const jsonFiles = getJsonFiles(dataDir);

  console.log('Found JSON files:', jsonFiles);

  // Combine all JSON data
  const combinedData = jsonFiles.reduce((acc, file) => {
    console.log('Processing file:', file);
    const data = readJsonFile(file);
    return mergeData(acc, data);
  }, {});

  // Add reference data
  combinedData.enums = {
    systemStatus: [
      { id: 1, name: "active" },
      { id: 2, name: "inactive" },
      { id: 3, name: "maintenance" },
      { id: 4, name: "retired" }
    ],
    atoStatus: [
      { id: 1, name: "not_started" },
      { id: 2, name: "in_progress" },
      { id: 3, name: "approved" },
      { id: 4, name: "denied" },
      { id: 5, name: "expired" }
    ],
    securityLevel: [
      { id: 1, name: "low" },
      { id: 2, name: "moderate" },
      { id: 3, name: "high" }
    ],
    informationLevel: [
      { id: 1, name: "public" },
      { id: 2, name: "internal" },
      { id: 3, name: "confidential" },
      { id: 4, name: "restricted" }
    ],
    systemCategory: [
      { id: 1, name: "financial" },
      { id: 2, name: "operational" },
      { id: 3, name: "administrative" },
      { id: 4, name: "security" }
    ],
    networkTypes: [
      { id: 1, name: "LAN" },
      { id: 2, name: "WAN" },
      { id: 3, name: "Cloud" },
      { id: 4, name: "VPN" },
      { id: 5, name: "DMZ" }
    ],
    componentTypes: [
      { id: 1, name: "Server" },
      { id: 2, name: "Database" },
      { id: 3, name: "Application" },
      { id: 4, name: "Network Device" },
      { id: 5, name: "Security Appliance" }
    ],
    procedureTypes: [
      { id: 1, name: "Backup" },
      { id: 2, name: "Recovery" },
      { id: 3, name: "Maintenance" },
      { id: 4, name: "Security" },
      { id: 5, name: "Monitoring" }
    ]
  };

  combinedData.commonPorts = [
    { id: 1, port: 80, service: "HTTP" },
    { id: 2, port: 443, service: "HTTPS" },
    { id: 3, port: 22, service: "SSH" },
    { id: 4, port: 3306, service: "MySQL" },
    { id: 5, port: 5432, service: "PostgreSQL" }
  ];

  // Write the combined data to db.json
  writeFileSync(outputFile, JSON.stringify(combinedData, null, 2));
  console.log('Generated db.json successfully');
};

// Run the generator
generateDb();

================
File: mocks/incidentMockData.js
================
// Mock incidents
export const mockIncidents = [
  {
    id: 1,
    clientId: 1,
    title: 'Unauthorized Access Attempt',
    type: 'security',
    severity: 'high',
    status: 'active',
    priority: 'high',
    createdAt: '2024-02-19T08:00:00Z',
    updatedAt: '2024-02-19T10:30:00Z',
    resolvedAt: null,
    assignedTo: 'Security Operations',
    description: 'Multiple failed login attempts detected from suspicious IP addresses',
    affectedSystems: ['Authentication Server', 'User Database'],
    actions: [
      {
        id: 1,
        type: 'detection',
        timestamp: '2024-02-19T08:00:00Z',
        description: 'IDS detected multiple failed login attempts',
        performedBy: 'Security Operations'
      },
      {
        id: 2,
        type: 'mitigation',
        timestamp: '2024-02-19T08:15:00Z',
        description: 'IP addresses temporarily blocked',
        performedBy: 'Alice Brown'
      },
      {
        id: 3,
        type: 'investigation',
        timestamp: '2024-02-19T10:30:00Z',
        description: 'Analysis of login attempt patterns',
        performedBy: 'Security Operations'
      }
    ]
  },
  {
    id: 2,
    clientId: 1,
    title: 'Data Backup Failure',
    type: 'system',
    severity: 'medium',
    status: 'resolved',
    priority: 'medium',
    createdAt: '2024-02-18T15:00:00Z',
    updatedAt: '2024-02-18T17:45:00Z',
    resolvedAt: '2024-02-18T17:45:00Z',
    assignedTo: 'Information Technology',
    description: 'Scheduled backup job failed due to storage capacity issues',
    affectedSystems: ['Backup System', 'Storage System'],
    actions: [
      {
        id: 1,
        type: 'detection',
        timestamp: '2024-02-18T15:00:00Z',
        description: 'Backup job failure alert received',
        performedBy: 'Information Technology'
      },
      {
        id: 2,
        type: 'investigation',
        timestamp: '2024-02-18T15:30:00Z',
        description: 'Storage capacity analysis performed',
        performedBy: 'David Wilson'
      },
      {
        id: 3,
        type: 'resolution',
        timestamp: '2024-02-18T17:45:00Z',
        description: 'Additional storage allocated and backup job rerun successfully',
        performedBy: 'Information Technology'
      }
    ]
  },
  {
    id: 3,
    clientId: 1,
    title: 'SSL Certificate Expiration',
    type: 'security',
    severity: 'medium',
    status: 'active',
    priority: 'high',
    createdAt: '2024-02-19T09:00:00Z',
    updatedAt: '2024-02-19T09:30:00Z',
    resolvedAt: null,
    assignedTo: 'Security Operations',
    description: 'SSL certificate for main website approaching expiration',
    affectedSystems: ['Web Server'],
    actions: [
      {
        id: 1,
        type: 'detection',
        timestamp: '2024-02-19T09:00:00Z',
        description: 'Certificate expiration alert received',
        performedBy: 'Security Operations'
      },
      {
        id: 2,
        type: 'mitigation',
        timestamp: '2024-02-19T09:30:00Z',
        description: 'Certificate renewal process initiated',
        performedBy: 'Alice Brown'
      }
    ]
  },
  {
    id: 4,
    clientId: 1,
    title: 'Network Performance Degradation',
    type: 'network',
    severity: 'high',
    status: 'investigating',
    priority: 'high',
    createdAt: '2024-02-19T11:00:00Z',
    updatedAt: '2024-02-19T11:45:00Z',
    resolvedAt: null,
    assignedTo: 'Network Operations',
    description: 'Users reporting slow network performance and intermittent connectivity issues',
    affectedSystems: ['Network Infrastructure', 'Cloud Services'],
    actions: [
      {
        id: 1,
        type: 'detection',
        timestamp: '2024-02-19T11:00:00Z',
        description: 'Multiple user reports of slow network performance',
        performedBy: 'Information Technology'
      },
      {
        id: 2,
        type: 'investigation',
        timestamp: '2024-02-19T11:45:00Z',
        description: 'Network monitoring analysis initiated',
        performedBy: 'Sarah Johnson'
      }
    ]
  }
];

// Incident types
export const mockIncidentTypes = [
  'security',
  'system',
  'network',
  'application',
  'hardware',
  'software',
  'data',
  'user',
  'other'
];

// Incident severities
export const mockIncidentSeverities = [
  'critical',
  'high',
  'medium',
  'low'
];

// Incident statuses
export const mockIncidentStatuses = [
  'active',
  'investigating',
  'mitigated',
  'resolved',
  'closed'
];

// Incident priorities
export const mockIncidentPriorities = [
  'critical',
  'high',
  'medium',
  'low'
];

// Action types
export const mockActionTypes = [
  'detection',
  'investigation',
  'mitigation',
  'resolution',
  'communication',
  'escalation'
];

// Teams (matching departments from clientMockData)
export const mockTeams = [
  'Information Technology',
  'Security Operations',
  'Risk & Compliance',
  'Network Operations'
];

// Affected system types
export const mockSystemTypes = [
  'Web Server',
  'Database Server',
  'Authentication Server',
  'Network Infrastructure',
  'Storage System',
  'Backup System',
  'End User Systems',
  'Security Systems',
  'Cloud Services'
];

================
File: mocks/middleware.js
================
/* eslint-disable no-undef */
export default (req, res, next) => {
  if (req.method === 'POST' && req.path === '/auth/login') {
    const { email, password } = req.body;
    const db = require('./db.json');
    
    const user = db.users.find(u => u.email === email && u.password === password);
    
    if (user) {
      // Create a simple token (in production this would be a proper JWT)
      const token = Buffer.from(JSON.stringify({
        id: user.id,
        email: user.email,
        role: user.role
      })).toString('base64');

      // Remove sensitive data
      const {  ...safeUser } = user;

      res.json({
        user: safeUser,
        token,
        message: 'Login successful'
      });
    } else {
      res.status(401).json({
        error: 'Invalid email or password'
      });
    }
    return;
  }
  next();
}

================
File: mocks/riskMockData.js
================
// Mock risk data
export const mockRisks = [
  {
    id: 'r-001',
    clientId: 1,
    name: 'Insufficient Access Controls',
    description: 'Current access control mechanisms do not meet security requirements',
    impact: 'high',
    likelihood: 'medium',
    category: 'Access Control',
    status: 'active',
    lastAssessed: '2024-02-15T08:00:00Z',
    sourceFindings: [
      {
        findingId: 'f-1',
        title: 'Missing MFA Implementation',
        sourceType: 'security_assessment',
        date: '2024-02-15T08:00:00Z'
      }
    ],
    businessImpact: {
      financial: 'Potential unauthorized access could lead to financial losses',
      operational: 'System access issues could disrupt operations',
      reputational: 'Security breaches could damage company reputation',
      compliance: 'Non-compliance with security standards'
    },
    treatment: {
      approach: 'mitigate',
      plan: 'Implement MFA and enhance access controls',
      status: 'in_progress',
      objectives: ['obj-1', 'obj-2'],
      lastUpdated: '2024-02-16T10:00:00Z'
    }
  },
  {
    id: 'r-002',
    clientId: 1,
    name: 'Unencrypted Data Storage',
    description: 'Sensitive data stored without proper encryption',
    impact: 'high',
    likelihood: 'high',
    category: 'Data Protection',
    status: 'active',
    lastAssessed: '2024-02-14T09:00:00Z',
    sourceFindings: [
      {
        findingId: 'f-2',
        title: 'Unencrypted Database Backups',
        sourceType: 'vulnerability_scan',
        date: '2024-02-14T09:00:00Z'
      }
    ],
    businessImpact: {
      financial: 'Data breach could result in significant fines',
      operational: 'Data protection issues could affect system performance',
      reputational: 'Data breaches could severely impact trust',
      compliance: 'Direct violation of data protection regulations'
    },
    treatment: {
      approach: 'mitigate',
      plan: 'Implement database and backup encryption',
      status: 'not_started',
      objectives: ['obj-3'],
      lastUpdated: '2024-02-14T09:00:00Z'
    }
  },
  {
    id: 'r-003',
    clientId: 1,
    name: 'Outdated System Components',
    description: 'Critical system components running outdated versions',
    impact: 'medium',
    likelihood: 'high',
    category: 'Vulnerability Management',
    status: 'active',
    lastAssessed: '2024-02-13T14:00:00Z',
    sourceFindings: [
      {
        findingId: 'f-3',
        title: 'Multiple Systems Running Outdated Software',
        sourceType: 'external_audit',
        date: '2024-02-13T14:00:00Z'
      }
    ],
    businessImpact: {
      financial: 'Potential system failures could impact revenue',
      operational: 'System instability affects productivity',
      reputational: 'Service disruptions could affect client trust',
      compliance: 'Non-compliance with security requirements'
    },
    treatment: {
      approach: 'mitigate',
      plan: 'Implement systematic update process',
      status: 'in_progress',
      objectives: ['obj-4'],
      lastUpdated: '2024-02-13T15:00:00Z'
    }
  },
  {
    id: 'r-004',
    clientId: 1,
    name: 'Inadequate Backup Procedures',
    description: 'Current backup procedures do not meet recovery requirements',
    impact: 'high',
    likelihood: 'medium',
    category: 'Business Continuity',
    status: 'mitigated',
    lastAssessed: '2024-02-12T11:00:00Z',
    sourceFindings: [
      {
        findingId: 'f-4',
        title: 'Backup Recovery Tests Failed',
        sourceType: 'security_assessment',
        date: '2024-02-12T11:00:00Z'
      }
    ],
    businessImpact: {
      financial: 'Data loss could result in significant recovery costs',
      operational: 'System recovery issues could extend downtime',
      reputational: 'Extended service disruptions affect client confidence',
      compliance: 'Non-compliance with business continuity requirements'
    },
    treatment: {
      approach: 'mitigate',
      plan: 'Implement automated backup system with regular testing',
      status: 'completed',
      objectives: ['obj-5'],
      lastUpdated: '2024-02-12T16:00:00Z'
    }
  },
  {
    id: 'r-005',
    clientId: 1,
    name: 'Insufficient Security Monitoring',
    description: 'Limited visibility into security events and incidents',
    impact: 'medium',
    likelihood: 'medium',
    category: 'Security Operations',
    status: 'active',
    lastAssessed: '2024-02-11T13:00:00Z',
    sourceFindings: [
      {
        findingId: 'f-5',
        title: 'Incomplete Security Event Logging',
        sourceType: 'security_assessment',
        date: '2024-02-11T13:00:00Z'
      }
    ],
    businessImpact: {
      financial: 'Delayed incident response could increase damages',
      operational: 'Limited visibility affects security operations',
      reputational: 'Security incidents could go undetected',
      compliance: 'Non-compliance with monitoring requirements'
    },
    treatment: {
      approach: 'mitigate',
      plan: 'Implement SIEM solution with 24/7 monitoring',
      status: 'in_progress',
      objectives: ['obj-6'],
      lastUpdated: '2024-02-11T14:00:00Z'
    }
  }
];

================
File: mocks/routes.json
================
{
  "/clients": "/clients",
  "/clients/:id": "/clients/:id",
  "/clients/:id/departments": "/departments?clientId=:id",
  "/clients/:id/documents": "/documents?clientId=:id",
  
  "/departments": "/departments",
  "/departments/:id": "/departments/:id",
  "/departments/:id/positions": "/departments/:id/positions",
  
  "/documents": "/documents",
  "/documents/:id": "/documents/:id",
  "/documentCategories": "/documentCategories",
  "/documentTypes": "/documentTypes",
  
  "/industries": "/industries",
  "/clientSizes": "/clientSizes",
  "/clientStatuses": "/clientStatuses",
  
  "/auth/login": "/users?email=:email",
  "/auth/me": "/users/:id",
  
  "/assessments/questions/basic": "/basicQuestions",
  "/assessments/questions/advanced": "/advancesQuestions",
  
  "/assessments": "/assessmentHistory",
  "/assessments/:id": "/assessmentHistory/:id",
  "/assessments/client/:clientId": "/assessmentHistory?clientId=:clientId",
  "/assessments/system/:systemId": "/assessmentHistory?systemId=:systemId",
  
  "/findings": "/assessmentHistory",
  "/findings/:id": "/assessmentHistory/:id",
  "/findings/:id/promote": {
    "target": "/assessmentHistory/:id",
    "method": "PATCH"
  },

  "/incidents": "/incidents",
  "/incidents/:id": "/incidents/:id",
  "/incidents?clientId=:clientId": "/incidents?clientId=:clientId",
  "/incidentTypes": "/incidentTypes",
  "/incidentSeverities": "/incidentSeverities",
  "/incidentStatuses": "/incidentStatuses",
  "/incidentPriorities": "/incidentPriorities",
  "/actionTypes": "/actionTypes",
  "/teams": "/teams",
  "/systemTypes": "/systemTypes"
}

================
File: mocks/securityAssessmentsMockData.js
================
// Mock security assessments data
export const mockSecurityAssessments = [
  {
    id: 'sa-1',
    clientId: 1,
    type: 'basic',
    name: 'Basic Security Assessment Q1 2024',
    date: '2024-01-15T10:00:00Z',
    status: 'completed',
    score: 75,
    reviewer: {
      name: 'Alice Brown',
      role: 'CISO',
      department: 'Security Operations'
    },
    answers: {
      1: 'yes',  // Antivirus
      2: 'yes',  // Firewall
      3: 'no',   // MFA
      4: 'yes',  // Password Policy
      5: 'yes',  // Security Training
      6: 'yes',  // Backup
      7: 'no',   // Encryption
      8: 'yes',  // Patch Management
      9: 'yes',  // Network Monitoring
      10: 'no',  // Incident Response
      11: 'yes', // Access Control
      12: 'yes'  // Security Policies
    },
    recommendations: [
      {
        id: 'rec-1',
        category: 'Access Control',
        recommendation: 'Implement Multi-Factor Authentication',
        impact: 'Strengthens access security and reduces unauthorized access risk',
        priority: 'high',
        status: 'pending'
      },
      {
        id: 'rec-2',
        category: 'Data Protection',
        recommendation: 'Implement data encryption',
        impact: 'Protects sensitive data from unauthorized access',
        priority: 'high',
        status: 'in_progress'
      },
      {
        id: 'rec-3',
        category: 'Incident Response',
        recommendation: 'Develop incident response plan',
        impact: 'Improves response time and effectiveness during security incidents',
        priority: 'medium',
        status: 'pending'
      }
    ],
    generatedFindings: [
      {
        id: 'f-1', // Reference to finding in auditMockData
        title: 'Insufficient password complexity requirements',
        severity: 'high',
        category: 'Access Control'
      },
      {
        id: 'f-4',
        title: 'Missing Multi-Factor Authentication',
        severity: 'high',
        category: 'Access Control'
      },
      {
        id: 'f-5',
        title: 'Incomplete encryption implementation',
        severity: 'medium',
        category: 'Data Protection'
      }
    ]
  },
  {
    id: 'sa-2',
    clientId: 1,
    type: 'advanced',
    name: 'Advanced Security Assessment Q1 2024',
    date: '2024-02-01T10:00:00Z',
    status: 'completed',
    score: 82,
    reviewer: {
      name: 'Michael Chen',
      role: 'Risk Director',
      department: 'Risk & Compliance'
    },
    answers: {
      'dp1': ['PII', 'Financial', 'Intellectual Property'],
      'dp2': 'AES-256 encryption for databases and file storage, with key rotation',
      'dp3': 8,
      'ac1': 'Yes',
      'ac2': 'Minimum 12 characters, complexity requirements, 90-day rotation',
      'ac3': 7,
      'ir1': 'Yes',
      'ir2': 'Automated monitoring and alerting with incident response team on call',
      'ir3': 9
    },
    recommendations: [
      {
        id: 'rec-4',
        category: 'Data Protection',
        recommendation: 'Expand data classification coverage',
        impact: 'Ensures proper handling of all sensitive data types',
        priority: 'high',
        status: 'completed'
      },
      {
        id: 'rec-5',
        category: 'Access Control',
        recommendation: 'Enhance access control measures',
        impact: 'Strengthens overall security posture',
        priority: 'medium',
        status: 'in_progress'
      },
      {
        id: 'rec-6',
        category: 'Incident Response',
        recommendation: 'Improve incident response capabilities',
        impact: 'Reduces impact of security incidents',
        priority: 'medium',
        status: 'deferred'
      }
    ],
    generatedFindings: [
      {
        id: 'f-6',
        title: 'Incomplete data classification',
        severity: 'medium',
        category: 'Data Protection'
      },
      {
        id: 'f-7',
        title: 'Access control maturity gaps',
        severity: 'medium',
        category: 'Access Control'
      }
    ]
  }
];

// Assessment types with detailed question structures
export const assessmentTypes = {
  basic: {
    name: 'Basic Assessment',
    description: 'Initial security evaluation covering fundamental controls',
    estimatedTime: '1-2 hours',
    recommendedFrequency: 'Quarterly',
    categories: [
      'Access Control',
      'Data Protection',
      'Network Security',
      'System Security',
      'Security Awareness',
      'Incident Response'
    ],
    questions: [
      {
        id: 1,
        text: 'Is antivirus software installed and updated on all systems?',
        category: 'System Security',
        findingTemplate: {
          title: 'Missing or outdated antivirus protection',
          severity: 'high',
          recommendation: 'Install and configure antivirus software on all systems with automatic updates'
        }
      },
      {
        id: 2,
        text: 'Are firewalls configured and maintained on all network boundaries?',
        category: 'Network Security',
        findingTemplate: {
          title: 'Inadequate firewall protection',
          severity: 'high',
          recommendation: 'Deploy and configure firewalls at all network boundaries'
        }
      }
      // Additional questions would be defined here
    ]
  },
  advanced: {
    name: 'Advanced Assessment',
    description: 'Comprehensive security evaluation with detailed analysis',
    estimatedTime: '4-6 hours',
    recommendedFrequency: 'Semi-annually',
    categories: [
      'Data Protection',
      'Access Control',
      'Incident Response',
      'Network Architecture',
      'Cloud Security',
      'Application Security',
      'Security Operations',
      'Compliance'
    ],
    sections: [
      {
        id: 'dp',
        name: 'Data Protection',
        questions: [
          {
            id: 'dp1',
            text: 'What types of sensitive data are stored or processed?',
            type: 'multi-select',
            options: ['PII', 'Financial', 'Health', 'Intellectual Property'],
            findingTemplate: {
              title: 'Incomplete data classification',
              severity: 'medium',
              recommendation: 'Implement comprehensive data classification program'
            }
          }
          // Additional questions would be defined here
        ]
      }
      // Additional sections would be defined here
    ]
  }
};

// Assessment statuses
export const assessmentStatuses = [
  'scheduled',
  'in_progress',
  'pending_review',
  'completed',
  'archived'
];

// Recommendation priorities
export const recommendationPriorities = [
  'critical',
  'high',
  'medium',
  'low'
];

// Recommendation statuses
export const recommendationStatuses = [
  'pending',
  'in_progress',
  'completed',
  'deferred'
];

// Finding severity mapping based on assessment responses
export const findingSeverityMapping = {
  critical: {
    conditions: ['Multiple high-risk findings', 'Immediate business impact'],
    requiredActions: ['Immediate notification', 'Executive briefing']
  },
  high: {
    conditions: ['Single high-risk finding', 'Potential business impact'],
    requiredActions: ['48-hour response', 'Management notification']
  },
  medium: {
    conditions: ['Control gaps', 'Limited exposure'],
    requiredActions: ['Planned remediation', 'Regular updates']
  },
  low: {
    conditions: ['Minor issues', 'Policy violations'],
    requiredActions: ['Track in backlog', 'Include in reporting']
  }
};

// Assessment metrics
export const assessmentMetrics = {
  completed: {
    last30Days: 5,
    last90Days: 15,
    lastYear: 45
  },
  averageScores: {
    basic: 78,
    advanced: 82
  },
  findingsGenerated: {
    total: 127,
    byType: {
      basic: 85,
      advanced: 42
    }
  },
  trends: {
    scoreImprovement: '+5%',
    findingReduction: '-12%',
    completionRate: '95%'
  }
};

================
File: mocks/securityControlsMockData.js
================
// Mock Security Control Data
export const mockSecurityControls = {
  technical: [
    {
      id: 'AC-1',
      number: 'AC-1',
      family: 'Access Control',
      title: 'Access Control Policy and Procedures',
      description: 'The organization develops, documents, and disseminates an access control policy and procedures.',
      implementationStatus: 'Partially Implemented',
      implementationDetails: '',
      baselineImpact: 'LOW',
      evidence: [
        {
          id: 'ev-1',
          title: 'Access Control Policy.pdf',
          dateAdded: '2024-02-19',
        },
      ],
      lastAssessed: '2024-02-19',
    },
    {
      id: 'AC-2',
      number: 'AC-2',
      family: 'Access Control',
      title: 'Account Management',
      description: 'The organization manages information system accounts, including establishing, activating, modifying, reviewing, disabling, and removing accounts.',
      implementationStatus: 'Implemented',
      implementationDetails: '',
      baselineImpact: 'LOW',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
    {
      id: 'AC-3',
      number: 'AC-3',
      family: 'Access Control',
      title: 'Access Enforcement',
      description: 'The system enforces approved authorizations for logical access to information and system resources.',
      implementationStatus: 'Not Implemented',
      implementationDetails: '',
      baselineImpact: 'MODERATE',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
  ],
  operational: [
    {
      id: 'AT-1',
      number: 'AT-1',
      family: 'Awareness and Training',
      title: 'Security Awareness and Training Policy and Procedures',
      description: 'The organization develops, documents, and disseminates security awareness and training policies and procedures.',
      implementationStatus: 'Not Implemented',
      implementationDetails: '',
      baselineImpact: 'LOW',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
    {
      id: 'AT-2',
      number: 'AT-2',
      family: 'Awareness and Training',
      title: 'Security Awareness Training',
      description: 'The organization provides basic security awareness training to information system users.',
      implementationStatus: 'Not Implemented',
      implementationDetails: '',
      baselineImpact: 'LOW',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
    {
      id: 'AT-3',
      number: 'AT-3',
      family: 'Awareness and Training',
      title: 'Role-Based Security Training',
      description: 'The organization provides role-based security training to personnel with assigned security roles and responsibilities.',
      implementationStatus: 'Not Implemented',
      implementationDetails: '',
      baselineImpact: 'MODERATE',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
  ],
  management: [
    {
      id: 'CA-1',
      number: 'CA-1',
      family: 'Security Assessment',
      title: 'Security Assessment and Authorization Policies and Procedures',
      description: 'The organization develops, documents, and disseminates security assessment and authorization policies and procedures.',
      implementationStatus: 'Not Implemented',
      implementationDetails: '',
      baselineImpact: 'LOW',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
    {
      id: 'CA-2',
      number: 'CA-2',
      family: 'Security Assessment',
      title: 'Security Assessments',
      description: 'The organization develops a security assessment plan and conducts security assessments.',
      implementationStatus: 'Not Implemented',
      implementationDetails: '',
      baselineImpact: 'LOW',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
    {
      id: 'CA-3',
      number: 'CA-3',
      family: 'Security Assessment',
      title: 'System Interconnections',
      description: 'The organization documents and controls system interconnections.',
      implementationStatus: 'Not Implemented',
      implementationDetails: '',
      baselineImpact: 'MODERATE',
      evidence: [],
      lastAssessed: '2024-02-19',
    },
  ],
};

// Mock Statistics Data
export const mockControlStats = {
  overallProgress: 35,
  statusBreakdown: {
    'Implemented': 12,
    'Partially Implemented': 24,
    'Not Implemented': 45,
    'Not Applicable': 8,
  },
};

// Mock Control Families
export const mockControlFamilies = [
  { id: 'AC', name: 'Access Control' },
  { id: 'AT', name: 'Awareness and Training' },
  { id: 'AU', name: 'Audit and Accountability' },
  { id: 'CA', name: 'Security Assessment and Authorization' },
  { id: 'CM', name: 'Configuration Management' },
  { id: 'CP', name: 'Contingency Planning' },
  { id: 'IA', name: 'Identification and Authentication' },
  { id: 'IR', name: 'Incident Response' },
  { id: 'MA', name: 'Maintenance' },
  { id: 'MP', name: 'Media Protection' },
  { id: 'PE', name: 'Physical and Environmental Protection' },
  { id: 'PL', name: 'Planning' },
  { id: 'PS', name: 'Personnel Security' },
  { id: 'RA', name: 'Risk Assessment' },
  { id: 'SA', name: 'System and Services Acquisition' },
  { id: 'SC', name: 'System and Communications Protection' },
  { id: 'SI', name: 'System and Information Integrity' },
];

================
File: mocks/securityInitiativesMockData.js
================
// Mock security initiatives
export const mockInitiatives = [
  {
    id: 1,
    clientId: 1,
    name: 'MFA Implementation',
    description: 'Deploy multi-factor authentication across all systems and applications',
    phase: 'Phase 2',
    timeline: '2024 Q2',
    status: 'In Progress',
    objectiveId: 1, // Zero Trust Architecture
    milestones: [
      { id: 1, name: 'MFA Solution Selection', completed: true },
      { id: 2, name: 'Identity Provider Integration', completed: true },
      { id: 3, name: 'User Enrollment', completed: false },
      { id: 4, name: 'Legacy System Integration', completed: false }
    ],
    resources: {
      team: ['Security Operations', 'Information Technology'],
      budget: '120,000',
      tools: ['Identity Management Platform', 'MFA Solution']
    }
  },
  {
    id: 2,
    clientId: 1,
    name: 'Network Segmentation',
    description: 'Implement network segmentation and micro-segmentation',
    phase: 'Phase 2',
    timeline: '2024 Q3',
    status: 'In Progress',
    objectiveId: 1, // Zero Trust Architecture
    milestones: [
      { id: 1, name: 'Network Assessment', completed: true },
      { id: 2, name: 'Segmentation Design', completed: true },
      { id: 3, name: 'Implementation', completed: false },
      { id: 4, name: 'Testing and Validation', completed: false }
    ],
    resources: {
      team: ['Network Operations', 'Security Operations'],
      budget: '250,000',
      tools: ['Network Management System', 'Security Tools']
    }
  },
  {
    id: 3,
    clientId: 1,
    name: 'Data Encryption Program',
    description: 'Implement end-to-end encryption for sensitive data',
    phase: 'Phase 1',
    timeline: '2024 Q3',
    status: 'Planning',
    objectiveId: 2, // Enhance Data Protection
    milestones: [
      { id: 1, name: 'Data Classification', completed: false },
      { id: 2, name: 'Encryption Solution Deployment', completed: false },
      { id: 3, name: 'Key Management Setup', completed: false },
      { id: 4, name: 'User Training', completed: false }
    ],
    resources: {
      team: ['Information Technology', 'Security Operations'],
      budget: '180,000',
      tools: ['Encryption Solution', 'Key Management System']
    }
  },
  {
    id: 4,
    clientId: 1,
    name: 'Security Awareness Training',
    description: 'Deploy comprehensive security awareness training program',
    phase: 'Phase 3',
    timeline: '2024 Q1',
    status: 'Completed',
    objectiveId: 3, // Security Awareness Program
    milestones: [
      { id: 1, name: 'Training Platform Setup', completed: true },
      { id: 2, name: 'Content Development', completed: true },
      { id: 3, name: 'Employee Training', completed: true },
      { id: 4, name: 'Effectiveness Assessment', completed: true }
    ],
    resources: {
      team: ['Security Operations', 'Risk & Compliance'],
      budget: '75,000',
      tools: ['Learning Management System', 'Phishing Simulator']
    }
  },
  {
    id: 5,
    clientId: 1,
    name: 'Network Performance Upgrade',
    description: 'Upgrade network infrastructure and monitoring capabilities',
    phase: 'Phase 2',
    timeline: '2024 Q3',
    status: 'In Progress',
    objectiveId: 4, // Network Infrastructure Modernization
    milestones: [
      { id: 1, name: 'Infrastructure Assessment', completed: true },
      { id: 2, name: 'Hardware Upgrades', completed: false },
      { id: 3, name: 'Monitoring Implementation', completed: false },
      { id: 4, name: 'Performance Testing', completed: false }
    ],
    resources: {
      team: ['Network Operations', 'Information Technology'],
      budget: '350,000',
      tools: ['Network Monitoring Tools', 'Performance Analytics']
    }
  },
  {
    id: 6,
    clientId: 1,
    name: 'Compliance Documentation',
    description: 'Develop and maintain comprehensive compliance documentation',
    phase: 'Phase 2',
    timeline: '2024 Q3',
    status: 'In Progress',
    objectiveId: 5, // Compliance Framework Implementation
    milestones: [
      { id: 1, name: 'Framework Selection', completed: true },
      { id: 2, name: 'Documentation Development', completed: true },
      { id: 3, name: 'Control Implementation', completed: false },
      { id: 4, name: 'Internal Audit', completed: false }
    ],
    resources: {
      team: ['Risk & Compliance', 'Security Operations'],
      budget: '120,000',
      tools: ['GRC Platform', 'Documentation System']
    }
  },
  {
    id: 7,
    clientId: 1,
    name: 'Cloud Security Controls',
    description: 'Implement cloud security controls and monitoring',
    phase: 'Phase 2',
    timeline: '2024 Q3',
    status: 'In Progress',
    objectiveId: 6, // Cloud Security Enhancement
    milestones: [
      { id: 1, name: 'Cloud Security Assessment', completed: true },
      { id: 2, name: 'Control Implementation', completed: false },
      { id: 3, name: 'Monitoring Setup', completed: false },
      { id: 4, name: 'Security Testing', completed: false }
    ],
    resources: {
      team: ['Information Technology', 'Security Operations'],
      budget: '200,000',
      tools: ['Cloud Security Platform', 'Monitoring Tools']
    }
  }
];

// Initiative status options
export const mockInitiativeStatus = [
  'Planning',
  'In Progress',
  'Completed',
  'On Hold',
  'Cancelled'
];

// Phase options
export const mockPhases = [
  'Phase 1',
  'Phase 2',
  'Phase 3',
  'Phase 4'
];

// Timeline options
export const mockTimelines = [
  '2024 Q1',
  '2024 Q2',
  '2024 Q3',
  '2024 Q4',
  '2025 Q1'
];

// Resource categories
export const mockResourceCategories = [
  'Team',
  'Budget',
  'Tools',
  'Vendors',
  'Infrastructure'
];

================
File: mocks/securityObjectivesMockData.js
================
// Mock security objectives
export const mockObjectives = [
  {
    id: 1,
    clientId: 1,
    name: 'Implement Zero Trust Architecture',
    description: 'Transform network security to a Zero Trust model with enhanced access controls and network segmentation',
    progress: 65,
    status: 'In Progress',
    dueDate: '2024-12-31',
    priority: 'High',
    owner: 'Security Operations',
    assignedTo: 'Alice Brown',
    relatedRisks: [1],
    metrics: {
      successCriteria: ['MFA adoption rate > 95%', 'Network segmentation complete', 'Identity-based access controls implemented'],
      currentMetrics: ['MFA adoption: 82%', 'Segmentation: 60% complete', 'Identity controls: In progress']
    }
  },
  {
    id: 2,
    clientId: 1,
    name: 'Enhance Data Protection Controls',
    description: 'Strengthen data protection mechanisms across all systems including encryption and DLP implementation',
    progress: 40,
    status: 'In Progress',
    dueDate: '2024-09-30',
    priority: 'High',
    owner: 'Information Technology',
    assignedTo: 'David Wilson',
    relatedRisks: [2],
    metrics: {
      successCriteria: ['100% sensitive data encrypted', 'DLP implementation complete', 'Backup systems upgraded'],
      currentMetrics: ['Encryption: 85% complete', 'DLP: Planning phase', 'Backup upgrade: 50% complete']
    }
  },
  {
    id: 3,
    clientId: 1,
    name: 'Security Awareness Program',
    description: 'Implement comprehensive security awareness training program for all employees',
    progress: 90,
    status: 'Completed',
    dueDate: '2024-03-31',
    priority: 'Medium',
    owner: 'Security Operations',
    assignedTo: 'Alice Brown',
    relatedRisks: [1, 2],
    metrics: {
      successCriteria: ['95% training completion rate', 'Phishing test success < 5%', 'Monthly awareness sessions'],
      currentMetrics: ['Training: 98% complete', 'Phishing success: 3%', 'Sessions: On track']
    }
  },
  {
    id: 4,
    clientId: 1,
    name: 'Network Infrastructure Modernization',
    description: 'Upgrade and modernize network infrastructure to improve performance and security',
    progress: 30,
    status: 'In Progress',
    dueDate: '2024-11-30',
    priority: 'High',
    owner: 'Network Operations',
    assignedTo: 'Sarah Johnson',
    relatedRisks: [3],
    metrics: {
      successCriteria: ['Network performance improved by 50%', 'New monitoring tools implemented', '99.99% uptime achieved'],
      currentMetrics: ['Performance: +20%', 'Monitoring: In progress', 'Uptime: 99.95%']
    }
  },
  {
    id: 5,
    clientId: 1,
    name: 'Compliance Framework Implementation',
    description: 'Implement and maintain comprehensive compliance framework across organization',
    progress: 55,
    status: 'In Progress',
    dueDate: '2024-10-31',
    priority: 'High',
    owner: 'Risk & Compliance',
    assignedTo: 'Michael Chen',
    relatedRisks: [4],
    metrics: {
      successCriteria: ['Framework documentation complete', 'All controls implemented', 'Audit readiness achieved'],
      currentMetrics: ['Documentation: 75%', 'Controls: 60%', 'Audit prep: In progress']
    }
  },
  {
    id: 6,
    clientId: 1,
    name: 'Cloud Security Enhancement',
    description: 'Strengthen security controls and monitoring for cloud infrastructure',
    progress: 45,
    status: 'In Progress',
    dueDate: '2024-08-31',
    priority: 'High',
    owner: 'Information Technology',
    assignedTo: 'David Wilson',
    relatedRisks: [5],
    metrics: {
      successCriteria: ['Cloud security baseline established', 'Monitoring implemented', 'Access controls reviewed'],
      currentMetrics: ['Baseline: In progress', 'Monitoring: 70%', 'Access review: 50%']
    }
  }
];

// Objective status options
export const mockObjectiveStatus = [
  'Planning',
  'In Progress',
  'Completed',
  'On Hold',
  'Cancelled'
];

// Priority levels
export const mockPriorityLevels = [
  'Low',
  'Medium',
  'High',
  'Critical'
];

// Metric categories
export const mockMetricCategories = [
  'Security',
  'Performance',
  'Compliance',
  'Training',
  'Infrastructure'
];

// Success criteria types
export const mockSuccessCriteriaTypes = [
  'Percentage',
  'Completion',
  'Implementation',
  'Measurement',
  'Timeline'
];

================
File: mocks/systemComponentsMockData.js
================
export const mockComponents = [
  {
    id: '1',
    type: 'PHYSICAL',
    name: 'Primary Database Server',
    description: 'Main database server hosting customer data',
    specifications: {
      manufacturer: 'Dell',
      model: 'PowerEdge R740',
      cpu: 'Intel Xeon Gold 6248R',
      ram: '384GB',
      storage: '4TB SSD RAID-10'
    },
    status: 'ACTIVE',
    lastUpdated: '2024-02-19T10:00:00Z'
  },
  {
    id: '2',
    type: 'VIRTUAL',
    name: 'Web Application Server',
    description: 'Primary web application server',
    specifications: {
      os: 'Ubuntu 22.04 LTS',
      vcpus: 8,
      ram: '32GB',
      storage: '500GB'
    },
    status: 'ACTIVE',
    lastUpdated: '2024-02-19T10:00:00Z'
  },
  {
    id: '3',
    type: 'NETWORK',
    name: 'Core Switch',
    description: 'Primary network switch for data center',
    specifications: {
      manufacturer: 'Cisco',
      model: 'Catalyst 9300',
      ports: '48x 10GbE',
      throughput: '960 Gbps'
    },
    status: 'ACTIVE',
    lastUpdated: '2024-02-19T10:00:00Z'
  }
];

export const mockComponentTypes = [
  'PHYSICAL',
  'VIRTUAL',
  'NETWORK',
  'SECURITY_APPLIANCE'
];

export const mockComponentStatuses = [
  'ACTIVE',
  'INACTIVE',
  'MAINTENANCE',
  'DECOMMISSIONED'
];

// Helper to generate unique IDs (moved from API file)
export const generateMockId = () => Math.random().toString(36).substr(2, 9);

================
File: mocks/systemMockData.js
================
// Enum definitions
export const SystemStatus = {
  DRAFT: 'DRAFT',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export const ATOStatus = {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  APPROVED: 'APPROVED',
  DENIED: 'DENIED',
  EXPIRED: 'EXPIRED'
};

export const SecurityLevel = {
  LOW: 'low',
  MODERATE: 'moderate',
  HIGH: 'high'
};

export const InformationLevel = {
  PUBLIC: 'public',
  INTERNAL: 'internal',
  CONFIDENTIAL: 'confidential',
  RESTRICTED: 'restricted'
};

export const SystemCategory = {
  MISSION_CRITICAL: 'Mission Critical',
  BUSINESS_CRITICAL: 'Business Critical',
  BUSINESS_OPERATIONAL: 'Business Operational',
  BUSINESS_SUPPORT: 'Business Support'
};

// Mock data arrays
export const mockSystemTypes = [
  'Major Application',
  'General Support System',
  'Minor Application',
  'Other'
];

export const mockNetworkTypes = [
  'LAN',
  'WAN',
  'VPN',
  'Cloud',
  'Hybrid'
];

export const mockComponentTypes = [
  'Server',
  'Database',
  'Application',
  'Network Device',
  'Security Appliance'
];

export const mockProcedureTypes = [
  'Backup',
  'Recovery',
  'Maintenance',
  'Security',
  'Compliance'
];

export const mockCommonPorts = [
  { port: 80, service: 'HTTP' },
  { port: 443, service: 'HTTPS' },
  { port: 22, service: 'SSH' },
  { port: 3306, service: 'MySQL' },
  { port: 5432, service: 'PostgreSQL' }
];

export const mockSystems = [
  {
    id: "sys-001",  // Changed from 1 to match the format used in createSystem
    clientId: 1,
    name: "Core Banking Platform",
    type: "Major Application",
    category: SystemCategory.MISSION_CRITICAL,
    securityLevel: SecurityLevel.HIGH,
    informationLevel: InformationLevel.CONFIDENTIAL,
    status: SystemStatus.IN_PROGRESS,
    atoStatus: ATOStatus.IN_PROGRESS,
    currentPhase: "initial_assessment",
    createdAt: "2025-02-20T10:00:00Z",
    updatedAt: "2025-02-20T10:30:00Z",
    lastAssessment: null,
    phaseProgress: {
      "initial-assessment": 65,
      "system-categorization": 30,
      "security-controls": 10,
      "assessment": 0,
      "ato-authorization": 0,
      "continuous-monitoring": 0
    },
    phases: {
      initialAssessment: {
        discovery: {
          status: "in_progress",
          completedItems: [
            "System inventory",
            "System purpose documentation"
          ],
          pendingItems: [
            "Data flow mapping",
            "System boundaries"
          ]
        },
        gapAnalysis: {
          status: "in_progress",
          completedItems: [
            "Current state assessment"
          ],
          pendingItems: [
            "Control gap identification",
            "Security practice review"
          ]
        },
        environment: {
          status: "completed",
          details: {
            hosting: "Hybrid",
            components: ["Web Servers", "Database Clusters", "Load Balancers"]
          }
        },
        stakeholders: {
          status: "not_started",
          identified: [],
          pending: ["System Owner", "Security Officer", "Operations Team"]
        }
      },
      systemCategorization: {
        infoTypes: {
          status: "in_progress",
          identified: [
            "Customer Data",
            "Transaction Records"
          ],
          pending: [
            "Audit Logs",
            "Configuration Data"
          ]
        },
        impact: {
          status: "not_started",
          assessments: {
            confidentiality: null,
            integrity: null,
            availability: null
          }
        },
        objectives: {
          status: "not_started",
          defined: [],
          pending: [
            "Data Protection Goals",
            "System Availability Targets",
            "Compliance Requirements"
          ]
        }
      },
      securityControls: {
        baseline: {
          status: "not_started",
          selected: null,
          rationale: null
        },
        tailoring: {
          status: "not_started",
          completedControls: [],
          pendingControls: []
        },
        implementation: {
          status: "not_started",
          implemented: [],
          pending: []
        },
        documentation: {
          status: "not_started",
          completed: [],
          pending: [
            "Security Policies",
            "Procedures",
            "Training Materials"
          ]
        }
      },
      assessment: {
        planning: {
          status: "not_started",
          completed: [],
          pending: [
            "Assessment Plan",
            "Test Procedures",
            "Tool Selection"
          ]
        },
        testing: {
          status: "not_started",
          completed: [],
          pending: [
            "Vulnerability Scans",
            "Penetration Tests",
            "Control Testing"
          ]
        },
        review: {
          status: "not_started",
          completed: [],
          pending: [
            "Documentation Review",
            "Evidence Validation",
            "Findings Documentation"
          ]
        }
      },
      authorization: {
        riskAssessment: {
          status: "not_started",
          completed: [],
          pending: [
            "Risk Analysis",
            "Mitigation Planning",
            "Residual Risk Assessment"
          ]
        },
        package: {
          status: "not_started",
          completed: [],
          pending: [
            "Package Assembly",
            "Documentation Review",
            "Executive Summary"
          ]
        },
        decision: {
          status: "not_started",
          result: null,
          conditions: []
        }
      },
      continuousMonitoring: {
        program: {
          status: "not_started",
          defined: [],
          pending: [
            "Monitoring Strategy",
            "Metrics Definition",
            "Reporting Requirements"
          ]
        },
        assessment: {
          status: "not_started",
          completed: [],
          pending: [
            "Control Effectiveness",
            "Metric Collection",
            "Risk Updates"
          ]
        },
        maintenance: {
          status: "not_started",
          completed: [],
          pending: [
            "System Updates",
            "Documentation Maintenance",
            "Training Updates"
          ]
        }
      }
    },
    components: [],
    networks: [],
    ports: [],
    procedures: [],
    artifacts: [],
    boundaries: {
      physical: [],
      network: [],
      security: []
    },
    compliance: {
      nist: 0,
      hipaa: 0,
      pci: 0
    }
  }
];

export const getSystem = (clientId, systemId) => {
  return mockSystems.find(s => s.clientId === clientId && s.id === systemId) || null;
};

export const updateSystem = (clientId, systemId, updates) => {
  const index = mockSystems.findIndex(s => s.clientId === clientId && s.id === systemId);
  if (index !== -1) {
    mockSystems[index] = { ...mockSystems[index], ...updates };
    return mockSystems[index];
  }
  return null;
};

export const updatePhaseStatus = (clientId, systemId, phase, status) => {
  const system = getSystem(clientId, systemId);
  if (system && system.phases[phase]) {
    system.phases[phase].status = status;
    return system;
  }
  return null;
};

================
File: mocks/userMockData.js
================
// User roles enum
export const USER_ROLES = {
  PROGRAM_MANAGER: 'PROGRAM_MANAGER',
  ISSM: 'ISSM',
  ISSO: 'ISSO',
  ISSE: 'ISSE',
  SYSTEM_ADMIN: 'SYSTEM_ADMIN'
};

// Role-based permissions
export const ROLE_PERMISSIONS = {
  [USER_ROLES.PROGRAM_MANAGER]: ['manage_users', 'manage_systems', 'view_audits', 'manage_strategy'],
  [USER_ROLES.ISSM]: ['manage_users', 'manage_systems', 'manage_audits', 'manage_strategy'],
  [USER_ROLES.ISSO]: ['view_users', 'manage_systems', 'manage_audits'],
  [USER_ROLES.ISSE]: ['view_users', 'view_systems', 'view_audits'],
  [USER_ROLES.SYSTEM_ADMIN]: ['all']
};

// Available permissions
export const AVAILABLE_PERMISSIONS = [
  'manage_users',
  'view_users',
  'manage_systems',
  'view_systems',
  'manage_audits',
  'view_audits',
  'manage_strategy',
  'all'
];

// Mock user data
export const mockUsers = [
  {
    id: 1,
    username: 'john.smith',
    email: 'john.smith@acme.com',
    role: USER_ROLES.PROGRAM_MANAGER,
    clientId: 'client-1',
    firstName: 'John',
    lastName: 'Smith',
    title: 'Program Manager',
    department: 'Security',
    phone: '(555) 123-4567',
    isActive: true,
    lastActive: '2024-02-19T10:00:00Z',
    permissions: ROLE_PERMISSIONS[USER_ROLES.PROGRAM_MANAGER]
  },
  {
    id: 2,
    username: 'sarah.johnson',
    email: 'sarah.johnson@acme.com',
    role: USER_ROLES.ISSM,
    clientId: 'client-1',
    firstName: 'Sarah',
    lastName: 'Johnson',
    title: 'Information System Security Manager',
    department: 'Security',
    phone: '(555) 234-5678',
    isActive: true,
    lastActive: '2024-02-19T09:00:00Z',
    permissions: ROLE_PERMISSIONS[USER_ROLES.ISSM]
  },
  {
    id: 3,
    username: 'mike.wilson',
    email: 'mike.wilson@acme.com',
    role: USER_ROLES.ISSO,
    clientId: 'client-1',
    firstName: 'Mike',
    lastName: 'Wilson',
    title: 'Information System Security Officer',
    department: 'IT',
    phone: '(555) 345-6789',
    isActive: true,
    lastActive: '2024-02-19T08:00:00Z',
    permissions: ROLE_PERMISSIONS[USER_ROLES.ISSO]
  },
  {
    id: 4,
    username: 'alice.brown',
    email: 'alice.brown@healthcareplus.com',
    role: USER_ROLES.PROGRAM_MANAGER,
    clientId: 'client-2',
    firstName: 'Alice',
    lastName: 'Brown',
    title: 'Security Program Manager',
    department: 'Security',
    phone: '(555) 456-7890',
    isActive: true,
    lastActive: '2024-02-19T11:00:00Z',
    permissions: ROLE_PERMISSIONS[USER_ROLES.PROGRAM_MANAGER]
  },
  {
    id: 5,
    username: 'admin',
    email: 'admin@grc.com',
    role: USER_ROLES.SYSTEM_ADMIN,
    clientId: null,
    firstName: 'System',
    lastName: 'Administrator',
    title: 'System Administrator',
    department: 'IT',
    phone: '(555) 999-9999',
    isActive: true,
    lastActive: '2024-02-19T12:00:00Z',
    permissions: ROLE_PERMISSIONS[USER_ROLES.SYSTEM_ADMIN]
  }
];

// User departments
export const mockDepartments = [
  'Security',
  'IT',
  'Compliance',
  'Risk Management',
  'Operations',
  'Executive'
];

// User titles
export const mockTitles = [
  'Program Manager',
  'Information System Security Manager',
  'Information System Security Officer',
  'Security Engineer',
  'System Administrator',
  'Security Analyst',
  'Compliance Officer',
  'Risk Manager'
];

// User status options
export const mockUserStatus = [
  'active',
  'inactive',
  'suspended',
  'pending'
];

================
File: system/artifactsApi.js
================
import { artifactsMockData, artifactTypes } from '../mocks/artifactsMockData';

let artifacts = [...artifactsMockData];

export const artifactsApi = {
  // Get all artifacts
  getAllArtifacts: async () => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(artifacts);
      }, 500);
    });
  },

  // Get artifact by ID
  getArtifactById: async (id) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const artifact = artifacts.find(a => a.id === id);
        if (artifact) {
          resolve(artifact);
        } else {
          reject(new Error('Artifact not found'));
        }
      }, 500);
    });
  },

  // Create new artifact
  createArtifact: async (artifactData) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const newArtifact = {
          id: `art-${String(artifacts.length + 1).padStart(3, '0')}`,
          uploadDate: new Date().toISOString(),
          ...artifactData
        };
        artifacts.push(newArtifact);
        resolve(newArtifact);
      }, 500);
    });
  },

  // Update artifact
  updateArtifact: async (id, updateData) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const index = artifacts.findIndex(a => a.id === id);
        if (index !== -1) {
          artifacts[index] = {
            ...artifacts[index],
            ...updateData,
            id // Ensure ID cannot be changed
          };
          resolve(artifacts[index]);
        } else {
          reject(new Error('Artifact not found'));
        }
      }, 500);
    });
  },

  // Delete artifact
  deleteArtifact: async (id) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const index = artifacts.findIndex(a => a.id === id);
        if (index !== -1) {
          artifacts = artifacts.filter(a => a.id !== id);
          resolve({ success: true });
        } else {
          reject(new Error('Artifact not found'));
        }
      }, 500);
    });
  },

  // Get artifact types
  getArtifactTypes: async () => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(artifactTypes);
      }, 500);
    });
  },

  // Upload artifact file (mock implementation)
  uploadArtifactFile: async (file) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        // Simulate file upload and return a mock URL
        const mockUrl = `/artifacts/${file.name}`;
        resolve({
          fileUrl: mockUrl,
          fileType: file.type,
          size: file.size
        });
      }, 1000);
    });
  }
};

export default artifactsApi;

================
File: system/atoTrackerApi.js
================
import { delay } from '../apiHelpers';
import { atoTrackerMockData } from '../mocks/atoTrackerMockData';

const atoTrackerApi = {
  // Get ATO process data for a system
  getATOProcess: async (clientId, systemId) => {
    await delay(500); // Simulate API delay
    return atoTrackerMockData.getProcessData(systemId);
  },

  // Update task status
  updateTaskStatus: async (clientId, systemId, phaseId, sectionTitle, taskIndex, completed) => {
    await delay(300); // Simulate API delay
    return atoTrackerMockData.updateTaskStatus(systemId, phaseId, sectionTitle, taskIndex, completed);
  },

  // Get phase progress
  getPhaseProgress: async (clientId, systemId, phaseId) => {
    await delay(200); // Simulate API delay
    return atoTrackerMockData.getPhaseProgress(systemId, phaseId);
  },

  // Reset process data (useful for testing)
  resetProcessData: async () => {
    await delay(200);
    atoTrackerMockData.resetMockData();
  }
};

export default atoTrackerApi;

================
File: system/authorizationApi.js
================
import { handleApiResponse, handleApiError } from '../apiHelpers';
import authorizationMockData from '../mocks/authorizationMockData';

const BASE_URL = import.meta.env.VITE_API_BASE_URL;
const USE_MOCK = import.meta.env.VITE_USE_MOCK === 'true';

const authorizationApi = {
  // Get authorization data for a system
  getAuthorizationData: async (clientId, systemId) => {
    if (USE_MOCK) return authorizationMockData.getAuthorizationData(clientId, systemId);
    
    try {
      const response = await fetch(
        `${BASE_URL}/clients/${clientId}/systems/${systemId}/authorization`
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Update risk assessment
  updateRiskAssessment: async (clientId, systemId, riskData) => {
    if (USE_MOCK) return authorizationMockData.updateRiskAssessment(clientId, systemId, riskData);
    
    try {
      const response = await fetch(
        `${BASE_URL}/clients/${clientId}/systems/${systemId}/authorization/risk-assessment`,
        {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(riskData),
        }
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Create POA&M item
  createPOAMItem: async (clientId, systemId, poamItem) => {
    if (USE_MOCK) return authorizationMockData.createPOAMItem(clientId, systemId, poamItem);
    
    try {
      const response = await fetch(
        `${BASE_URL}/clients/${clientId}/systems/${systemId}/authorization/poam`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(poamItem),
        }
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Update authorization package
  updateAuthorizationPackage: async (clientId, systemId, packageData) => {
    if (USE_MOCK) return authorizationMockData.updateAuthorizationPackage(clientId, systemId, packageData);
    
    try {
      const response = await fetch(
        `${BASE_URL}/clients/${clientId}/systems/${systemId}/authorization/package`,
        {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(packageData),
        }
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Validate authorization package
  validateAuthorizationPackage: async (clientId, systemId) => {
    if (USE_MOCK) return authorizationMockData.validateAuthorizationPackage(clientId, systemId);
    
    try {
      const response = await fetch(
        `${BASE_URL}/clients/${clientId}/systems/${systemId}/authorization/package/validate`,
        {
          method: 'POST',
        }
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Update authorization decision
  updateAuthorizationDecision: async (clientId, systemId, decisionData) => {
    if (USE_MOCK) return authorizationMockData.updateAuthorizationDecision(clientId, systemId, decisionData);
    
    try {
      const response = await fetch(
        `${BASE_URL}/clients/${clientId}/systems/${systemId}/authorization/decision`,
        {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(decisionData),
        }
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },
};

export default authorizationApi;

================
File: system/systemApi.js
================
import { delay, getCurrentDate, validateRequired, checkExists } from '../apiHelpers';
import {
  mockSystems,
  SystemStatus,
  ATOStatus,
  SecurityLevel,
  InformationLevel,
  SystemCategory,
  mockNetworkTypes,
  mockComponentTypes,
  mockProcedureTypes,
  mockCommonPorts
} from '../mocks/systemMockData';
import { mockAuthData } from '../mocks/authorizationMockData';

// Re-export enums for backward compatibility
export { SystemStatus, ATOStatus, SecurityLevel, InformationLevel, SystemCategory };

// In-memory storage for CRUD operations
let systems = [...mockSystems];

export const systemApi = {
  getSystems: async (clientId) => {
    await delay(500);
    validateRequired({ clientId }, ['clientId']);
    
    const numericClientId = Number(clientId);
    const filteredSystems = systems.filter(s => s.clientId === numericClientId);
    return [...filteredSystems];
  },

  getSystemTypes: async () => {
    await delay(300);
    return [
      'Major Application',
      'General Support System',
      'Minor Application',
      'Other'
    ];
  },

  getNetworkTypes: async () => {
    await delay(300);
    return [...mockNetworkTypes];
  },

  getComponentTypes: async () => {
    await delay(300);
    return [...mockComponentTypes];
  },

  getProcedureTypes: async () => {
    await delay(300);
    return [...mockProcedureTypes];
  },

  getCommonPorts: async () => {
    await delay(300);
    return [...mockCommonPorts];
  },

  getSystemStatuses: async () => {
    await delay(300);
    return Object.values(SystemStatus);
  },

  getATOStatuses: async () => {
    await delay(300);
    return Object.values(ATOStatus);
  },

  getSecurityLevels: async () => {
    await delay(300);
    return Object.values(SecurityLevel);
  },

  getInformationLevels: async () => {
    await delay(300);
    return Object.values(InformationLevel);
  },

  getSystemCategories: async () => {
    await delay(300);
    return Object.values(SystemCategory);
  },

  getSystem: async (clientId, systemId) => {
    await delay(300);
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const numericClientId = Number(clientId);
    const system = systems.find(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(system, 'System');

    // Get authorization data from mock data
    const authData = mockAuthData[clientId]?.[systemId] || {
      riskAssessment: { risks: [], nonCompliantControls: [] },
      package: {
        completed: [],
        pending: [],
        executiveSummary: '',
        status: 'not-started',
        validationStatus: 'pending',
        completionPercentage: 0,
      },
      decision: {
        result: '',
        official: '',
        date: '',
        expirationDate: '',
        justification: '',
        conditions: [],
        boundary: '',
      },
    };

    // Add authorization data to system response
    const systemWithAuth = {
      ...system,
      phases: {
        ...system.phases,
        authorization: authData
      }
    };
    
    return systemWithAuth;
  },

  createPOAMItem: async (clientId, systemId, poamData) => {
    await delay(800);
    validateRequired({ clientId, systemId, ...poamData }, ['clientId', 'systemId', 'controlId', 'mitigationPlan']);
    
    const numericClientId = Number(clientId);
    const systemIndex = systems.findIndex(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(systems[systemIndex], 'System');

    const newPOAM = {
      id: `poam-${Date.now()}`,
      ...poamData,
      status: 'OPEN',
      dateCreated: getCurrentDate(),
    };

    // Update system's authorization data
    if (!systems[systemIndex].phases) {
      systems[systemIndex].phases = {};
    }
    if (!systems[systemIndex].phases.authorization) {
      systems[systemIndex].phases.authorization = mockAuthData[clientId]?.[systemId] || {
        riskAssessment: { risks: [], nonCompliantControls: [] },
        package: { completed: [], pending: [] },
        decision: {},
      };
    }

    systems[systemIndex].phases.authorization.riskAssessment.risks.push(newPOAM);
    systems[systemIndex].updatedAt = getCurrentDate();

    return newPOAM;
  },

  updateAuthorizationPackage: async (clientId, systemId, packageData) => {
    await delay(500);
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const numericClientId = Number(clientId);
    const systemIndex = systems.findIndex(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(systems[systemIndex], 'System');

    // Ensure authorization data exists
    if (!systems[systemIndex].phases) {
      systems[systemIndex].phases = {};
    }
    if (!systems[systemIndex].phases.authorization) {
      systems[systemIndex].phases.authorization = mockAuthData[clientId]?.[systemId] || {
        riskAssessment: { risks: [], nonCompliantControls: [] },
        package: { completed: [], pending: [] },
        decision: {},
      };
    }

    // Update package data
    systems[systemIndex].phases.authorization.package = {
      ...systems[systemIndex].phases.authorization.package,
      ...packageData,
    };
    systems[systemIndex].updatedAt = getCurrentDate();

    return systems[systemIndex].phases.authorization.package;
  },

  updateAuthorizationDecision: async (clientId, systemId, decisionData) => {
    await delay(500);
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const numericClientId = Number(clientId);
    const systemIndex = systems.findIndex(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(systems[systemIndex], 'System');

    // Ensure authorization data exists
    if (!systems[systemIndex].phases) {
      systems[systemIndex].phases = {};
    }
    if (!systems[systemIndex].phases.authorization) {
      systems[systemIndex].phases.authorization = mockAuthData[clientId]?.[systemId] || {
        riskAssessment: { risks: [], nonCompliantControls: [] },
        package: { completed: [], pending: [] },
        decision: {},
      };
    }

    // Update decision data
    systems[systemIndex].phases.authorization.decision = {
      ...systems[systemIndex].phases.authorization.decision,
      ...decisionData,
    };
    systems[systemIndex].updatedAt = getCurrentDate();

    return systems[systemIndex].phases.authorization.decision;
  },

  validateAuthorizationPackage: async (clientId, systemId) => {
    await delay(1000);
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const numericClientId = Number(clientId);
    const system = systems.find(s => 
      s.clientId === numericClientId && 
      s.id === systemId
    );
    
    checkExists(system, 'System');

    // Simulate package validation
    return {
      status: 'VALIDATED',
      timestamp: getCurrentDate(),
      findings: [],
      recommendations: [
        'Ensure all POA&M items have detailed remediation plans',
        'Update system boundary documentation with network diagrams',
        'Include detailed testing results in security assessment report'
      ]
    };
  }
};

export default systemApi;

================
File: system/systemCategorizationApi.js
================
/* eslint-disable no-unused-vars */
import { handleApiResponse as handleResponse, handleApiError as handleError } from '../apiHelpers';


// Mock data for development
const mockData = {
  informationTypes: {
    types: [],
    customTypes: '',
    sensitivity: '',
    regulations: [],
    ownership: '',
    dataFlows: '',
    dataLifecycle: '',
    privacyRequirements: ''
  },
  impactAnalysis: {
    confidentiality: '',
    integrity: '',
    availability: '',
    rationale: '',
    categorization: ''
  },
  securityObjectives: {
    objectives: [],
    requirements: [],
    criticalFunctions: [],
    businessImpact: '',
    priorities: []
  }
};

export const systemCategorizationApi = {
  // Information Types
  getInformationTypes: async (clientId, systemId) => {
    try {
      // For development, return mock data
      return Promise.resolve(mockData.informationTypes);
    } catch (error) {
      return handleError(error);
    }
  },

  updateInformationTypes: async (clientId, systemId, data) => {
    try {
      // For development, log and return mock data
      console.log('Updating information types:', data);
      return Promise.resolve({ ...mockData.informationTypes, ...data });
    } catch (error) {
      return handleError(error);
    }
  },

  // Impact Analysis
  getImpactAnalysis: async (clientId, systemId) => {
    try {
      return Promise.resolve(mockData.impactAnalysis);
    } catch (error) {
      return handleError(error);
    }
  },

  updateImpactAnalysis: async (clientId, systemId, data) => {
    try {
      console.log('Updating impact analysis:', data);
      return Promise.resolve({ ...mockData.impactAnalysis, ...data });
    } catch (error) {
      return handleError(error);
    }
  },

  // Security Objectives
  getSecurityObjectives: async (clientId, systemId) => {
    try {
      return Promise.resolve(mockData.securityObjectives);
    } catch (error) {
      return handleError(error);
    }
  },

  updateSecurityObjectives: async (clientId, systemId, data) => {
    try {
      console.log('Updating security objectives:', data);
      return Promise.resolve({ ...mockData.securityObjectives, ...data });
    } catch (error) {
      return handleError(error);
    }
  },

  // Progress tracking
  getProgress: async (clientId, systemId) => {
    try {
      // Mock progress data
      return Promise.resolve({
        progress: 30,
        sections: {
          informationTypes: 'not_started',
          impactAnalysis: 'not_started',
          securityObjectives: 'not_started'
        }
      });
    } catch (error) {
      return handleError(error);
    }
  }
};

export default systemCategorizationApi;

================
File: system/systemComponentsApi.js
================
import { delay, validateRequired, checkExists, ApiError } from '../apiHelpers';
import {
  mockComponents,
  mockComponentTypes,
  mockComponentStatuses,
  generateMockId
} from '../mocks/systemComponentsMockData';

// Mutable copy of mock data for CRUD operations
let components = [...mockComponents];

export const systemComponentsApi = {
  // Get component types
  getComponentTypes: async () => {
    await delay(300);
    return [...mockComponentTypes];
  },
  
  // Get component statuses
  getComponentStatuses: async () => {
    await delay(300);
    return [...mockComponentStatuses];
  },

  // Get all components
  getComponents: async () => {
    await delay(500);
    return [...components];
  },

  // Get component by ID
  getComponent: async (id) => {
    await delay(300);
    const numericId = Number(id);
    const component = components.find(c => c.id === numericId);
    checkExists(component, 'Component');
    return { ...component };
  },

  // Create new component
  createComponent: async (componentData) => {
    await delay(500);
    validateRequired(componentData, ['name', 'type', 'description']);

    if (!mockComponentTypes.includes(componentData.type)) {
      throw new ApiError('Invalid component type', 400);
    }

    const newComponent = {
      id: generateMockId(),
      lastUpdated: new Date().toISOString(),
      status: 'ACTIVE',
      ...componentData
    };
    
    components.push(newComponent);
    return { ...newComponent };
  },

  // Update component
  updateComponent: async (id, updateData) => {
    await delay(500);
    const numericId = Number(id);
    const index = components.findIndex(c => c.id === numericId);
    checkExists(components[index], 'Component');

    if (updateData.type && !mockComponentTypes.includes(updateData.type)) {
      throw new ApiError('Invalid component type', 400);
    }

    if (updateData.status && !mockComponentStatuses.includes(updateData.status)) {
      throw new ApiError('Invalid component status', 400);
    }

    const updatedComponent = {
      ...components[index],
      ...updateData,
      lastUpdated: new Date().toISOString()
    };

    components[index] = updatedComponent;
    return { ...updatedComponent };
  },

  // Delete component
  deleteComponent: async (id) => {
    await delay(500);
    const numericId = Number(id);
    const index = components.findIndex(c => c.id === numericId);
    checkExists(components[index], 'Component');

    components = components.filter(c => c.id !== numericId);
    return { success: true, message: 'Component deleted successfully' };
  }
};

export default systemComponentsApi;

================
File: system/systemControlsApi.js
================
import { handleApiResponse, handleApiError } from '../apiHelpers';
import {
  mockSecurityControls,
  mockControlStats,
  mockControlFamilies,
} from '../mocks/securityControlsMockData';

const BASE_URL = import.meta.env.VITE_API_BASE_URL;
const IS_DEVELOPMENT = import.meta.env.DEV;

export const systemControlsApi = {
  // Get controls for a system with filtering options
  getControls: async (systemId, filters = {}) => {
    if (IS_DEVELOPMENT) {
      let controls = Object.values(mockSecurityControls).flat();
      
      // Filter by family if specified
      if (filters.family) {
        controls = controls.filter(control => control.family.startsWith(filters.family));
      }

      // Filter by impact level
      if (filters.impactLevel) {
        switch (filters.impactLevel) {
          case 'LOW':
            controls = controls.filter(control => control.baselineImpact === 'LOW');
            break;
          case 'MODERATE':
            controls = controls.filter(control => 
              ['LOW', 'MODERATE'].includes(control.baselineImpact)
            );
            break;
          case 'HIGH':
            controls = controls.filter(control => 
              ['LOW', 'MODERATE', 'HIGH'].includes(control.baselineImpact)
            );
            break;
        }
      }

      return controls;
    }

    try {
      const queryParams = new URLSearchParams();
      if (filters.family) queryParams.append('family', filters.family);
      if (filters.impactLevel) queryParams.append('impactLevel', filters.impactLevel);

      const response = await fetch(
        `${BASE_URL}/api/systems/${systemId}/controls?${queryParams}`
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Create a new control
  createControl: async (systemId, controlData) => {
    if (IS_DEVELOPMENT) {
      return { ...controlData, id: Date.now().toString() };
    }

    try {
      const response = await fetch(`${BASE_URL}/api/systems/${systemId}/controls`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(controlData),
      });
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Update a control
  updateControl: async (systemId, controlId, controlData) => {
    if (IS_DEVELOPMENT) {
      return { ...controlData, id: controlId };
    }

    try {
      const response = await fetch(`${BASE_URL}/api/systems/${systemId}/controls/${controlId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(controlData),
      });
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Update control implementation status
  updateControlStatus: async (systemId, controlId, status) => {
    if (IS_DEVELOPMENT) {
      return { id: controlId, status };
    }

    try {
      const response = await fetch(`${BASE_URL}/api/systems/${systemId}/controls/${controlId}/status`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ status }),
      });
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Get control families
  getControlFamilies: async (systemId) => {
    if (IS_DEVELOPMENT) {
      return mockControlFamilies;
    }

    try {
      const response = await fetch(
        `${BASE_URL}/api/systems/${systemId}/controls/families`
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Add evidence to a control
  addControlEvidence: async (systemId, controlId, evidence) => {
    if (IS_DEVELOPMENT) {
      return {
        id: Date.now().toString(),
        title: evidence.get('evidence').name,
        dateAdded: new Date().toISOString(),
      };
    }

    try {
      const response = await fetch(
        `${BASE_URL}/api/systems/${systemId}/controls/${controlId}/evidence`,
        {
          method: 'POST',
          body: evidence,
        }
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Delete evidence from a control
  deleteControlEvidence: async (systemId, controlId, evidenceId) => {
    if (IS_DEVELOPMENT) {
      return { success: true };
    }

    try {
      const response = await fetch(
        `${BASE_URL}/api/systems/${systemId}/controls/${controlId}/evidence/${evidenceId}`,
        {
          method: 'DELETE',
        }
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },

  // Get control implementation statistics
  getControlStats: async (systemId) => {
    if (IS_DEVELOPMENT) {
      return mockControlStats;
    }

    try {
      const response = await fetch(
        `${BASE_URL}/api/systems/${systemId}/controls/stats`
      );
      return handleApiResponse(response);
    } catch (error) {
      return handleApiError(error);
    }
  },
};

export default systemControlsApi;



================================================================
End of Codebase
================================================================
